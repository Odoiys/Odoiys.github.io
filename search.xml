<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>攻防世界</title>
      <link href="/2020/02/14/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
      <url>/2020/02/14/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="666"><a href="#666" class="headerlink" title="666"></a>666</h2><p>放入detectit查看发现是64位elf文件，peid什么都没发现。</p><p>看看ida中的伪代码：</p><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp){  char s; // [rsp+0h] [rbp-1E0h]  char v5; // [rsp+F0h] [rbp-F0h]  memset(&amp;s, 0, 0x1EuLL);  printf(&quot;Please Input Key: &quot;, 0LL);  __isoc99_scanf(&quot;%s&quot;, &amp;v5);  encode(&amp;v5, &amp;s);  if ( strlen(&amp;v5) == key )  {    if ( !strcmp(&amp;s, enflag) )      puts(&quot;You are Right&quot;);    else      puts(&quot;flag{This_1s_f4cker_flag}&quot;);  }  return 0;}</code></pre><p>结构很简单，输入的flag放到v5里面，然后再encode中加密，加密后的变量是s，然后比较长度，长度是key，key的值给出来了是18，然后加密后的s与系统中的变量enflag进行比较，相同则答案正确。</p><p>再看看encode中的加密过程：</p><pre><code class="c">int __fastcall encode(const char *a1, __int64 a2){  char v3[32]; // [rsp+10h] [rbp-70h]  char v4[32]; // [rsp+30h] [rbp-50h]  char v5[40]; // [rsp+50h] [rbp-30h]  int v6; // [rsp+78h] [rbp-8h]  int i; // [rsp+7Ch] [rbp-4h]  i = 0;  v6 = 0;  if ( strlen(a1) != key )    return puts(&quot;Your Length is Wrong&quot;);  for ( i = 0; i &lt; key; i += 3 )  {    v5[i] = key ^ (a1[i] + 6);    v4[i + 1] = (a1[i + 1] - 6) ^ key;    v3[i + 2] = a1[i + 2] ^ 6 ^ key;    *(_BYTE *)(a2 + i) = v5[i];    *(_BYTE *)(a2 + i + 1LL) = v4[i + 1];    *(_BYTE *)(a2 + i + 2LL) = v3[i + 2];  }  return a2;}</code></pre><p>将输入的字符串每三个为一组，第一个字母加6异或key的值也就是18，第二个字母减6异或key，第三个异或6异或key</p><p>然后逆向写出脚本：</p><pre><code class="python">a=[0x69,0x7a,0x77,0x68,0x72,0x6f,0x7a,0x22,0x22,0x77,0x22,0x76,0x2e,0x4b,0x22,0x2e,0x4e,0x69]key=18flag=&#39;&#39;for i in range(0,18,3):    flag+=chr((a[i]^key)-6)    flag+=chr((a[i+1]^key)+6)    flag+=chr(a[i+2]^key^6)print(flag)</code></pre><h2 id="流浪者"><a href="#流浪者" class="headerlink" title="流浪者"></a>流浪者</h2><p>是一个elf的文件，程序逻辑很简单，因为找不到main函数，所以直接用字符串找到有加密的地方就好了。</p><p>直接给出脚本</p><pre><code class="python">a=&#39;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&#39;b=&#39;KanXueCTF2019JustForhappy&#39;c=[]for i in range(len(b)):    for j in range(len(a)):        if a[j] == b[i]:            c.append(j)print(c)for i in range(0,len(c)):    if c[i]&gt;9 or c[i]&lt;0:        if c[i]&gt;35 or c[i]&lt;10:            if c[i]&gt;61 or c[i]&lt;36:                print(&quot;error&quot;)            else:                c[i] = c[i]+29            else:            c[i]=c[i]+87    else:        c[i]=c[i]+48print(c)flag=&#39;&#39;for i in range(len(c)):    flag+=chr(c[i])print(flag)</code></pre><h2 id="testre"><a href="#testre" class="headerlink" title="testre"></a>testre</h2><pre><code class="c">__int64 __fastcall sub_400700(void *a1, _QWORD *a2, __int64 a3, size_t a4){  unsigned __int8 *v4; // rcx  __int64 v6; // [rsp+0h] [rbp-C0h]  int c; // [rsp+8h] [rbp-B8h]  char v8; // [rsp+Fh] [rbp-B1h]  int v9; // [rsp+10h] [rbp-B0h]  bool v10; // [rsp+17h] [rbp-A9h]  unsigned __int8 *v11; // [rsp+18h] [rbp-A8h]  char v12; // [rsp+27h] [rbp-99h]  int v13; // [rsp+28h] [rbp-98h]  int v14; // [rsp+2Ch] [rbp-94h]  unsigned __int64 i; // [rsp+30h] [rbp-90h]  size_t n; // [rsp+38h] [rbp-88h]  size_t v17; // [rsp+40h] [rbp-80h]  size_t v18; // [rsp+48h] [rbp-78h]  size_t j; // [rsp+50h] [rbp-70h]  size_t v20; // [rsp+58h] [rbp-68h]  int v21; // [rsp+64h] [rbp-5Ch]  unsigned __int64 v22; // [rsp+68h] [rbp-58h]  int v23; // [rsp+74h] [rbp-4Ch]  __int64 *v24; // [rsp+78h] [rbp-48h]  __int64 v25; // [rsp+80h] [rbp-40h]  void *v26; // [rsp+88h] [rbp-38h]  int v27; // [rsp+94h] [rbp-2Ch]  size_t v28; // [rsp+98h] [rbp-28h]  __int64 v29; // [rsp+A0h] [rbp-20h]  _QWORD *v30; // [rsp+A8h] [rbp-18h]  void *s; // [rsp+B0h] [rbp-10h]  char v32; // [rsp+BFh] [rbp-1h]  s = a1;  v30 = a2;  v29 = a3;  v28 = a4;  v27 = 0xDEADBEEF;  v26 = malloc(0x100uLL);  v25 = v29;  v24 = &amp;v6;  v22 = 0LL;  v17 = 0LL;  for ( i = 0LL; i &lt; v28; ++i )  {    v13 = *(unsigned __int8 *)(v25 + i);    *((_BYTE *)v26 + i) = byte_400E90[i % 29] ^ v13;    *((_BYTE *)v26 + i) += *(_BYTE *)(v25 + i);  }                                                        //欺骗的部分，后面没有调用  while ( 1 )  {    v12 = 0;    if ( v17 &lt; v28 )      v12 = ~(*(_BYTE *)(v25 + v17) != 0);    if ( !(v12 &amp; 1) )      break;    ++v17;  }  n = ((unsigned __int64)(0x28F5C28F5C28F5C3LL * (unsigned __int128)(138 * (v28 - v17) &gt;&gt; 2) &gt;&gt; 64) &gt;&gt; 2) + 1;  v23 = ((unsigned __int64)(0xAAAAAAAAAAAAAAABLL * (unsigned __int128)((v17 + v28) &lt;&lt; 6) &gt;&gt; 64) &gt;&gt; 5) - 1;  v11 = (unsigned __int8 *)&amp;v6      - ((((unsigned __int64)(0x28F5C28F5C28F5C3LL * (unsigned __int128)(138 * (v28 - v17) &gt;&gt; 2) &gt;&gt; 64) &gt;&gt; 2) + 16) &amp; 0xFFFFFFFFFFFFFFF0LL);  memset(v11, 0, n);  v20 = v17;  v18 = n - 1;  while ( v20 &lt; v28 )  {    v21 = *(unsigned __int8 *)(v25 + v20);    for ( j = n - 1; ; --j )    {      v10 = 1;      if ( j &lt;= v18 )        v10 = v21 != 0;      if ( !v10 )        break;      v22 = v11[j] &lt;&lt; 6;      v21 += v11[j] &lt;&lt; 8;      v9 = 64;      v11[j] = v21 % 58;      *((_BYTE *)v26 + j) = v22 &amp; 0x3F;      v22 &gt;&gt;= 6;      v21 /= 58;      v27 /= v9;      if ( !j )        break;    }    ++v20;    v18 = j;  }  for ( j = 0LL; ; ++j )  {    v8 = 0;    if ( j &lt; n )      v8 = ~(v11[j] != 0);    if ( !(v8 &amp; 1) )      break;  }  if ( *v30 &gt; n + v17 - j )  {    if ( v17 )    {      c = 61;      memset(s, 49, v17);      memset(v26, c, v17);    }    v20 = v17;    while ( j &lt; n )    {      v4 = v11;      *((_BYTE *)s + v20) = byte_400EB0[v11[j]];      *((_BYTE *)v26 + v20++) = byte_400EF0[v4[j++]];//base64的符号表，但是这里也没有调用，看整个函数都使用的是base58的结构（因为有除以58）这个标志    }    *((_BYTE *)s + v20) = 0;    *v30 = v20 + 1;    if ( !strncmp((const char *)s, &quot;D9&quot;, 2uLL)      &amp;&amp; !strncmp((const char *)s + 20, &quot;Mp&quot;, 2uLL)      &amp;&amp; !strncmp((const char *)s + 18, &quot;MR&quot;, 2uLL)      &amp;&amp; !strncmp((const char *)s + 2, &quot;cS9N&quot;, 4uLL)      &amp;&amp; !strncmp((const char *)s + 6, &quot;9iHjM&quot;, 5uLL)      &amp;&amp; !strncmp((const char *)s + 11, &quot;LTdA8YS&quot;, 7uLL) )    {      HIDWORD(v6) = puts(&quot;correct!&quot;);    }    v32 = 1;    v14 = 1;  }  else  {    *v30 = n + v17 - j + 1;    v32 = 0;    v14 = 1;  }  return v32 &amp; 1;}</code></pre><p>找到这一段后，可以发现有两块是虚假的，函数中都标注出来了。</p><p>直接使用base58解码就好了</p><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>本题是对动态调试的考察，ida中的main函数如下：</p><pre><code class="c">int sub_401100(){  signed int v0; // esi  signed int v1; // esi  unsigned int v2; // edi  void **v3; // ebx  void **v4; // eax  int v5; // ecx  int v6; // ST04_4  int v7; // ST08_4  int v8; // ST0C_4  int v9; // eax  char *v10; // esi  int v11; // ecx  void **v12; // eax  signed int v13; // eax  int v14; // ecx  int v15; // eax  int v16; // eax  int v17; // eax  int v18; // eax  int v19; // eax  int v20; // eax  int v21; // eax  const char *v22; // edx  int v23; // eax  int result; // eax  int Dst; // [esp+14h] [ebp-124h]  char v26[4]; // [esp+20h] [ebp-118h]  char v27; // [esp+24h] [ebp-114h]  int v28; // [esp+5Ch] [ebp-DCh]  char v29; // [esp+61h] [ebp-D7h]  int v30; // [esp+64h] [ebp-D4h]  int v31; // [esp+68h] [ebp-D0h]  char v32; // [esp+6Ch] [ebp-CCh]  FILE *File; // [esp+70h] [ebp-C8h]  char v34; // [esp+84h] [ebp-B4h]  void *v35; // [esp+CCh] [ebp-6Ch]  int v36; // [esp+DCh] [ebp-5Ch]  unsigned int v37; // [esp+E0h] [ebp-58h]  void *v38; // [esp+E4h] [ebp-54h]  unsigned int v39; // [esp+F4h] [ebp-44h]  unsigned int v40; // [esp+F8h] [ebp-40h]  void *Memory[4]; // [esp+FCh] [ebp-3Ch]  unsigned int v42; // [esp+10Ch] [ebp-2Ch]  unsigned int v43; // [esp+110h] [ebp-28h]  __int128 v44; // [esp+114h] [ebp-24h]  __int16 v45; // [esp+124h] [ebp-14h]  char v46; // [esp+126h] [ebp-12h]  int v47; // [esp+134h] [ebp-4h]  v40 = 15;  v39 = 0;  LOBYTE(v38) = 0;  v47 = 0;  v37 = 15;  v36 = 0;  LOBYTE(v35) = 0;  LOBYTE(v47) = 1;  v0 = 0;  v42 = 1684630885;  LOWORD(v43) = 97;  *Memory = xmmword_40528C;  v45 = &#39;.&lt;&#39;;  v46 = 0;  v44 = xmmword_4052A4;  do  {    sub_4021E0(&amp;v35, 1u, (*(Memory + v0) ^ *(&amp;v44 + v0)) + 22);    ++v0;  }  while ( v0 &lt; 18 );  v1 = 0;  v43 = 15;  v42 = 0;  LOBYTE(Memory[0]) = 0;  LOBYTE(v47) = 2;  v2 = v37;  v3 = v35;  do  {    v4 = &amp;v35;    if ( v2 &gt;= 16 )      v4 = v3;    sub_4021E0(Memory, 1u, *(v4 + v1++) + 9);  }  while ( v1 &lt; 18 );  memset(&amp;Dst, 0, 184u);  sub_401620(&amp;Dst, v5, v6, v7, v8);  LOBYTE(v47) = 3;  if ( v26[*(Dst + 4)] &amp; 6 )  {    v9 = sub_402A00(std::cerr, &quot;?W?h?a?t h?a?p?p?e?n?&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v9, sub_402C50);    exit(-1);  }  sub_402E90(&amp;Dst, &amp;v38);  v10 = &amp;v27;  if ( File )  {    if ( !sub_4022F0(&amp;v27) )      v10 = 0;    if ( fclose(File) )      v10 = 0;  }  else  {    v10 = 0;  }  v32 = 0;  v29 = 0;  std::basic_streambuf&lt;char,std::char_traits&lt;char&gt;&gt;::_Init(&amp;v27);  v30 = dword_408590;  File = 0;  v31 = dword_408594;  v28 = 0;  if ( !v10 )    std::basic_ios&lt;char,std::char_traits&lt;char&gt;&gt;::setstate(&amp;Dst + *(Dst + 4), 2, 0);  v12 = Memory;  if ( v43 &gt;= 16 )    v12 = Memory[0];  v13 = sub_4020C0(&amp;v38, v11, v39, v12, v42);  v14 = std::cout;  if ( v13 )  {    v22 = &quot;=W=r=o=n=g=K=e=y=&quot;;  }  else  {    v15 = sub_402A00(std::cout, &quot;|------------------------------|&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v15, sub_402C50);    v16 = sub_402A00(std::cout, &quot;|==============================|&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v16, sub_402C50);    v17 = sub_402A00(std::cout, &quot;|==============================|&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v17, sub_402C50);    v18 = sub_402A00(std::cout, &quot;|==============================|&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v18, sub_402C50);    v19 = sub_402A00(std::cout, &quot;\\  /\\  /\\  /\\  /\\==============|&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v19, sub_402C50);    v20 = sub_402A00(std::cout, &quot; \\/  \\/  \\/  \\/  \\=============|&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v20, sub_402C50);    v21 = sub_402A00(std::cout, &quot;                 |-------------|&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v21, sub_402C50);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(std::cout, sub_402C50);    v14 = std::cout;    v22 = &quot;Congrats You got it!&quot;;  }  v23 = sub_402A00(v14, v22);  std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v23, sub_402C50);  sub_401570(&amp;v34);  std::basic_ios&lt;char,std::char_traits&lt;char&gt;&gt;::~basic_ios&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;v34);  if ( v43 &gt;= 0x10 )    sub_402630(Memory[0], v43 + 1);  if ( v2 &gt;= 0x10 )    sub_402630(v3, v2 + 1);  result = v40;  if ( v40 &gt;= 0x10 )    result = sub_402630(v38, v40 + 1);  return result;}</code></pre><p>该程序是要在指定的位置建立一个规定的内容文件，程序才能通过。</p><p>先建立好一个文本文件里面随便输入一些内容，然后在od中动态调试</p><p>用智能搜索字符串找到?W?h?a?t h?a?p?p?e?n?，然后对照ida反汇编找到main函数的入口位置，从头开始调试。</p><p>伪代码这个位置</p><pre><code class="c">v0 = 0;  v42 = 1684630885;  LOWORD(v43) = 97;  *Memory = xmmword_40528C;  v45 = &#39;.&lt;&#39;;  v46 = 0;  v44 = xmmword_4052A4;  do  {    sub_4021E0(&amp;v35, 1u, (*(Memory + v0) ^ *(&amp;v44 + v0)) + 22);    ++v0;  }  while ( v0 &lt; 18 );</code></pre><p>这段是系统内的两个变量生成的字符串，输入不影响。</p><p>对应的反汇编的位置是</p><pre><code class="assembly">.text:004011A0 loc_4011A0:                             ; CODE XREF: sub_401100+C4↓j.text:004011A0                 mov     al, byte ptr [ebp+esi+var_24].text:004011A4                 lea     ecx, [ebp+var_6C].text:004011A7                 xor     al, byte ptr [ebp+esi+Memory].text:004011AB                 add     al, 16h.text:004011AD                 mov     [ebp+var_128], al.text:004011B3                 push    dword ptr [ebp+var_128] ; char.text:004011B9                 push    1               ; Size.text:004011BB                 call    sub_4021E0.text:004011C0                 inc     esi.text:004011C1                 cmp     esi, 12h.text:004011C4                 jl      short loc_4011A0</code></pre><p>继续往下看</p><pre><code class="c">do  {    v4 = &amp;v35;    if ( v2 &gt;= 16 )      v4 = v3;    sub_4021E0(Memory, 1u, *(v4 + v1++) + 9);  }  while ( v1 &lt; 18 );</code></pre><p>这一段和上面的函数调用相同，同样生成了一组字符串</p><p>反汇编</p><pre><code class="assembly">.text:004011E0 loc_4011E0:                             ; CODE XREF: sub_401100+108↓j.text:004011E0                 cmp     edi, 10h.text:004011E3                 lea     eax, [ebp+var_6C].text:004011E6                 lea     ecx, [ebp+Memory].text:004011E9                 cmovnb  eax, ebx.text:004011EC                 mov     al, [eax+esi].text:004011EF                 add     al, 9.text:004011F1                 mov     [ebp+var_128], al.text:004011F7                 push    dword ptr [ebp+var_128] ; char.text:004011FD                 push    1               ; Size.text:004011FF                 call    sub_4021E0.text:00401204                 inc     esi.text:00401205                 cmp     esi, 12h.text:00401208                 jl      short loc_4011E0</code></pre><p>经过动态调试后，sub_401620这个函数是用来读取建立的文件中的内容的</p><p>再往下走</p><pre><code class="c"> if ( v43 &gt;= 16 )    v12 = Memory[0];  v13 = sub_4020C0(&amp;v38, v11, v39, v12, v42);  v14 = std::cout;  if ( v13 )  {    v22 = &quot;=W=r=o=n=g=K=e=y=&quot;;  }  else  {    v15 = sub_402A00(std::cout, &quot;|------------------------------|&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v15, sub_402C50);    v16 = sub_402A00(std::cout, &quot;|==============================|&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v16, sub_402C50);    v17 = sub_402A00(std::cout, &quot;|==============================|&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v17, sub_402C50);    v18 = sub_402A00(std::cout, &quot;|==============================|&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v18, sub_402C50);    v19 = sub_402A00(std::cout, &quot;\\  /\\  /\\  /\\  /\\==============|&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v19, sub_402C50);    v20 = sub_402A00(std::cout, &quot; \\/  \\/  \\/  \\/  \\=============|&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v20, sub_402C50);    v21 = sub_402A00(std::cout, &quot;                 |-------------|&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v21, sub_402C50);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(std::cout, sub_402C50);    v14 = std::cout;    v22 = &quot;Congrats You got it!&quot;;  }</code></pre><p>这一段是比较字符串的地方，用动态调试通过寄存器监视可以看出来，一个部分是你输入的字符串，另一个是第二个循环出来的字符串。如果正确就会输出congrats,如果不通过就输出wrong</p><p>对应的反汇编是</p><pre><code class="assembly">.text:00401310 loc_401310:                             ; CODE XREF: sub_401100+1F4↑j.text:00401310                 cmp     [ebp+var_28], 10h.text:00401314                 lea     eax, [ebp+Memory].text:00401317                 push    [ebp+var_2C].text:0040131A                 cmovnb  eax, [ebp+Memory].text:0040131E                 push    eax.text:0040131F                 push    [ebp+var_44].text:00401322                 push    ecx.text:00401323                 lea     ecx, [ebp+var_54]</code></pre><p>最后的flag就是第二次的循环的字符串</p><h2 id="BabyXor"><a href="#BabyXor" class="headerlink" title="BabyXor"></a>BabyXor</h2><p>本题考查的是手动脱壳。</p><p>先把文件放入ida中看源代码，反汇编是成堆的数据，显然是加壳了，但是又在查壳软件中找不到壳，可能是作者手动改文件头了，官方的wp中给的是把段地址改了。</p><p>把文件放到od中看看有什么突破口，</p><pre><code class="assembly">0043F000 &gt;  60              pushad0043F001    B9 00100300     mov ecx,0x310000043F006    BB 00100000     mov ebx,0x10000043F00B    BA 00004000     mov edx,babyXor.004000000043F010    03DA            add ebx,edx                              ; babyXor.&lt;ModuleEntryPoint&gt;0043F012    8033 23         xor byte ptr ds:[ebx],0x230043F015    43              inc ebx0043F016    E0 FA           loopdne short babyXor.0043F0120043F018    61              popad0043F019    E9 82D4FCFF     jmp babyXor.0040C4A0</code></pre><p>pushad和popad都在眼前，直接试试esp定律脱壳好了</p><p>先单走一个F8执行以下pushad，然后再右边的寄存器监视一栏右键esp点击HW break[ESP]再单走一个f9，来到了jmp处，再F8来到一个一堆数据的地方，使用ctrl+a这就是原文件本来的入口处，然后再push ebp的地方右键点击用olldump脱壳调试进程，进去后再点击脱壳。</p><p>生成新的文件后，程序内容很简单，有两种做法，一种是用ida写脚本输出flag，另一种是动态调试，这边给出ida脚本。</p><pre><code class="python">a=[0x66,0x6d,0x63,0x64,0x7f,0x37,0x35,0x30,0x30,0x6b,0x3a,0x3c,0x3b,0x20]b=[]e=[0x1a,0x0,0x0,0x51,0x5,0x11,0x54,0x56,0x55,0x59,0x1d,0x9,0x5d,0x12,0x0,0x0,0x0,0x0]c=[0x37,0x6f,0x38,0x62,0x36,0x7c,0x37,0x33,0x34,0x76,0x33,0x62,0x64,0x7a]for i in range(14):    b.append(i^a[i])print(b)flag1=&#39;&#39;for i in range(14):    flag1+=chr(b[i])print(flag1)d=[0x37]flag2=&#39;&#39;for i in range(1,14):    d.append(a[i]^c[i]^a[i-1])for i in range(len(d)):    flag2+=chr(d[i])print(flag2)#print(len(d))f=[]for i in range(13):    f.append(e[i+1]^d[i]^i)flag3=chr(0x37^0x1a)for i in range(13):    flag3+=chr(f[i])print(flag3)flag=flag1+flag2+flag3print(flag)</code></pre><p>动态调试比较简单，可以自己尝试。</p><h2 id="Replace"><a href="#Replace" class="headerlink" title="Replace"></a>Replace</h2><p>本题是AES的算法题</p><p>先把程序放入detectit里，然后发现有UPX的壳在里面，可以直接用软件脱掉不需要手脱。</p><p>脱完壳后放入ida查看源代码，有main函数就进入main函数。</p><p>代码如下</p><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp){  int v3; // kr00_4  char Buf; // [esp+4h] [ebp-2Ch]  char Dst; // [esp+5h] [ebp-2Bh]  Buf = 0;  memset(&amp;Dst, 0, 0x27u);  printf(&quot;Welcome The System\nPlease Input Key:&quot;);  gets_s(&amp;Buf, 40u);  v3 = strlen(&amp;Buf);  if ( (v3 - 35) &lt;= 2 )  {    if ( sub_401090(&amp;Buf, v3) == 1 )      printf(&quot;Well Done!\n&quot;);    else      printf(&quot;Your Wrong!\n&quot;);  }  return 0;}</code></pre><p>进入if比较的那个函数sub_401090。</p><p>如下：</p><pre><code class="c">signed int __fastcall sub_401090(int a1, int a2){  int v2; // ebx  int v4; // edx  char v5; // al  int v6; // esi  int v7; // edi  char v8; // al  int v9; // eax  char v10; // cl  int v11; // eax  int v12; // ecx  v2 = a1;  if ( a2 != 35 )    return -1;  v4 = 0;  while ( 1 )  {    v5 = *(v4 + v2);    v6 = (v5 &gt;&gt; 4) % 16;    v7 = (16 * v5 &gt;&gt; 4) % 16;    v8 = byte_402150[2 * v4];    if ( v8 &lt; 48 || v8 &gt; &#39;9&#39; )      v9 = v8 - 87;    else      v9 = v8 - 48;    v10 = byte_402151[2 * v4];    v11 = 16 * v9;    if ( v10 &lt; &#39;0&#39; || v10 &gt; &#39;9&#39; )      v12 = v10 - 87;    else      v12 = v10 - 48;    if ( byte_4021A0[16 * v6 + v7] != ((v11 + v12) ^ 25) )      break;    if ( ++v4 &gt;= 35 )      return 1;  }  return -1;}</code></pre><p>有点像AES，但是可以发现可以写个脚本求出16*v6+v7，flag就是这个，就是要把最后一个字符变成}</p><p>脚本如下：</p><pre><code class="python">a=&#39;2a49f69c38395cde96d6de96d6f4e025484954d6195448def6e2dad67786e21d5adae6&#39;#print(len(a)//2)v8=[]v9=[]for i in range(len(a)//2):    v8.append(ord(a[2*i]))for i in range(len(v8)):    if v8[i] &lt; 48 or v8[i] &gt; 57:        v9.append(v8[i]-87)     else:        v9.append(v8[i]-48)#print(v9)v11=[]v10=&#39;a49f69c38395cde96d6de96d6f4e025484954d6195448def6e2dad67786e21d5adae6&#39;for i in range(len(v9)):    v11.append(16*v9[i])print(v11)v12=[]v13=[]print(len(v10)//2)for i in range(len(v10)//2):    v13.append(ord(v10[2*i]))for i in range(len(v13)):    if v13[i] &lt; 48 or v13[i] &gt; 57:        v12.append(v13[i]-87)     else:        v12.append(v13[i]-48)v12.append(0)for i in range(len(v11)):    print((v11[i]+v12[i])^25)sbox=[99, 124, 119, 123, 242, 107, 111, 197,   48,   1, 103,  43, 254, 215, 171, 118,202, 130, 201, 125, 250,  89, 71, 240,  173, 212, 162, 175, 156, 164, 114, 192,183, 253, 147,  38,  54,  63, 247, 204,   52, 165, 229, 241, 113, 216,  49,  21,  4, 199,  35, 195,  24, 150,   5, 154, 7, 18, 128, 226, 235,  39, 178, 117,  9, 131,  44,  26,  27, 110,  90, 160,   82,  59, 214, 179,  41, 227,  47, 132, 83, 209,   0, 237,  32, 252, 177,  91,  106, 203, 190,  57,  74,  76,  88, 207,208, 239, 170, 251,  67,  77,  51, 133,   69 ,249,   2, 127,  80,  60, 159, 168, 81, 163,  64, 143, 146, 157,  56 ,245,  188 ,182, 218 , 33,  16 ,255, 243 ,210,205,  12 , 19, 236,  95, 151 , 68 , 23,  196 ,167, 126 , 61, 100 , 93 , 25 ,115, 96, 129 , 79, 220 , 34,  42 ,144 ,136,   70 ,238, 184 , 20, 222 , 94  ,11, 219,224,  50,  58,  10,  73,   6 , 36 , 92,  194 ,211, 172  ,98, 145 ,149, 228 ,121,231, 200,  55, 109, 141, 213 , 78 ,169,  108 , 86, 244 ,234, 101 ,122, 174,   8,186, 120,  37,  46,  28, 166 ,180 ,198,  232 ,221, 116  ,31,  75, 189, 139, 138,112,  62, 181, 102,  72,   3 ,246 , 14,   97 , 53,  87 ,185, 134, 193,  29, 158,225, 248, 152,  17, 105, 217 ,142 ,148,  155,  30, 135, 233, 206,  85,  40 ,223,140, 161, 137,  13, 191, 230 , 66 ,104,   65 ,153,  45,  15, 176,  84, 187,  22,]number=[]for i in range(len(v11)):    for j in range(256):        if sbox[j] == ((v11[i]+v12[i])^25):            number.append(j)print(number)flag1=&#39;&#39;for i in range(len(number)):    flag1+=chr(number[i])print(flag1)</code></pre>]]></content>
      
      
      <categories>
          
          <category> re wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> re </tag>
            
            <tag> writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>re入门简介</title>
      <link href="/2020/02/13/re%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/02/13/re%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一，语言基础"><a href="#一，语言基础" class="headerlink" title="一，语言基础"></a>一，语言基础</h1><h2 id="汇编语言："><a href="#汇编语言：" class="headerlink" title="汇编语言："></a>汇编语言：</h2><p>既然是逆向那么汇编语言必不可少，要知道汇编才能知道代码是如何出来的，汇编语言因为可移植性很差，所以有很多种汇编，但是必须要会的是x86和x86-64的汇编。</p><h3 id="汇编学习书籍：（20-30天）"><a href="#汇编学习书籍：（20-30天）" class="headerlink" title="汇编学习书籍：（20~30天）"></a>汇编学习书籍：（20~30天）</h3><p>《汇编语言》（王爽） 有这么一本就够了，如果学习或做题的时候遇到问题，可以选择用百度谷歌学习。</p><h3 id="汇编学习网站：（5天）"><a href="#汇编学习网站：（5天）" class="headerlink" title="汇编学习网站：（5天）"></a>汇编学习网站：（5天）</h3><p><a href="https://www.tutorialspoint.com/assembly_programming/assembly_variables.htm" target="_blank" rel="noopener">汇编学习网站</a></p><p>这个是必备的，在看完上本书后，这个是作为加强理解汇编的很好手段</p><h2 id="C语言：（所有的基础）"><a href="#C语言：（所有的基础）" class="headerlink" title="C语言：（所有的基础）"></a>C语言：（所有的基础）</h2><p>c语言这里不过多赘述，ida的伪代码就是类c代码，所以c的要求必须是会写。                                </p><h2 id="Python："><a href="#Python：" class="headerlink" title="Python："></a>Python：</h2><p>python现已经成为最流行的语言之一，在ctf领域也广受欢迎，写脚本或是编写小程序也是十分的方便。</p><h3 id="Python学习书籍：（30天）"><a href="#Python学习书籍：（30天）" class="headerlink" title="Python学习书籍：（30天）"></a>Python学习书籍：（30天）</h3><p>python编程：从入门到实践（蛇书）</p><p>Python基础教程（人民邮电出版社）</p><h2 id="其他语言："><a href="#其他语言：" class="headerlink" title="其他语言："></a>其他语言：</h2><p>目前经常会出的题目语言还包括：Golang,c#,vb,java,cpp…..</p><p>虽然会遇到，但是没必要全部细致地的学过，他们的需求只是能读下来就可以，建议学一下java，了解一下面对对象编程，学懂类等的含义，其他语言不需要学习，在学会c之后就可以读懂大部分，遇到不会的就百度或谷歌。</p><h1 id="二，平台基础及软件"><a href="#二，平台基础及软件" class="headerlink" title="二，平台基础及软件"></a>二，平台基础及软件</h1><h2 id="windows"><a href="#windows" class="headerlink" title="windows:"></a>windows:</h2><h3 id="平台知识基础："><a href="#平台知识基础：" class="headerlink" title="平台知识基础："></a>平台知识基础：</h3><p>了解pe文件，pe文件头，pe文件的结构，windows下的程序是如何运行。</p><h3 id="软件："><a href="#软件：" class="headerlink" title="软件："></a>软件：</h3><p>ida pro</p><p>olldbg</p><p>detect it</p><p>PEiD</p><p>WinHex</p><p>x64dbg</p><p>x32dbg</p><p>jadx-gui(android逆向)</p><p>dnspy</p><p>加密解密的一些工具</p><h2 id="LINUX"><a href="#LINUX" class="headerlink" title="LINUX:"></a>LINUX:</h2><h3 id="平台知识基础：-1"><a href="#平台知识基础：-1" class="headerlink" title="平台知识基础："></a>平台知识基础：</h3><p>elf文件的结构和文件头</p><p>linux基础指令的使用</p><h3 id="软件：-1"><a href="#软件：-1" class="headerlink" title="软件："></a>软件：</h3><p>GDB</p><p>objdump</p><p>z3求解器：</p><p>python2，python3</p><p>vim</p><h1 id="三，逆向知识"><a href="#三，逆向知识" class="headerlink" title="三，逆向知识"></a>三，逆向知识</h1><p>逆向的相关知识很多，这里无法一一列举，只能通过自己做题练习自己总结，或多去看吾爱破解和看雪平台的文章来学习新知识。</p><p>这里也推荐一些逆向知识学习的书籍和网站</p><h2 id="书籍："><a href="#书籍：" class="headerlink" title="书籍："></a>书籍：</h2><p>《加密与解密》（手里必须有一本）</p><p>《逆向工程核心原理》（建议）</p><p>《逆向工程入门指南》：<a href="https://wizardforcel.gitbooks.io/re-for-beginners/content/" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/re-for-beginners/content/</a></p><h2 id="网站："><a href="#网站：" class="headerlink" title="网站："></a>网站：</h2><p><a href="https://bbs.pediy.com/" target="_blank" rel="noopener">看雪论坛</a></p><p><a href="https://www.52pojie.cn/" target="_blank" rel="noopener">吾爱破解</a></p><h1 id="四，如何进行逆向旅程呢？"><a href="#四，如何进行逆向旅程呢？" class="headerlink" title="四，如何进行逆向旅程呢？"></a>四，如何进行逆向旅程呢？</h1><p>如果有目的的做事情会让你的目标更明确，效率更高，伴随着刷题的学习，会让你边练习边学习，再加上写wp的习惯可以让你更好的消化今天所学习的知识。所以刷题加总结wp是这趟旅程的交通工具。</p><p>交通工具找到了然后要规划好路线。逆向的初期不要进行的太难的训练。刚刚开始进行只需要一些简单的工具题就好了，先熟悉使用工具就好了，接触ida和od，以及在linux下如何读反汇编等等。。。推荐攻防世界的新手题目，虽然只有几道但是也够了，不会的地方记得要多查多问前辈，做完记得要总结，写wp。</p><p>从初期的小白到中期的小萌新，需要一段时间的练习，虽然很煎熬但是依然要坚持，当你能熟练地做出前面的题目时候就可以进行下一步了。工具题毕竟只是用来熟悉工具的使用和逆向题目的结构，并没有什么难度，此时你还不算进入逆向的领域。在中期的路上，可需要南邮的题库，攻防世界进阶的简单题目和buuctf的简单题目作为练习手段。这个时期的任务是能解开有简单的异或等位运算的题目，会简单的爆破脚本，要能很顺利读出伪代码的结构，能读懂部分汇编代码，会很简单的动态调试（ida远程linux调试和olldbg动态调试）。满足这些条件你就可以从中期走出来了。</p><p>如果从中期出来，那么恭喜你，你已经是一个菜鸟了，你已经非常优秀了。后期的旅程是相当的有趣，你可以接触加密的算法，学习逆向的更多技巧。这个时候你需要继续刷题外，还要开始大赛之旅，所有大赛题目都要尝试做，如果做不出来就进行复现，复现成功后进行总结，学习每个题目的技术，不会的就问各个大佬。这个时期还要自己根据对知识的理解出题目（自己肯定也要能做出来才行）。</p><p>走出后期后呢，恭喜你已经是这一行的优秀人才了，快去虐菜吧。</p>]]></content>
      
      
      <categories>
          
          <category> 逆向工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020hgame-re-wp</title>
      <link href="/2020/02/07/2020hgame-re-wp/"/>
      <url>/2020/02/07/2020hgame-re-wp/</url>
      
        <content type="html"><![CDATA[<p>本来出于个人原因是不想做hgame的，但是做了发现出题很有水品，害，真香。</p><h2 id="WEEK2"><a href="#WEEK2" class="headerlink" title="WEEK2:"></a>WEEK2:</h2><h3 id="unpack"><a href="#unpack" class="headerlink" title="unpack:"></a>unpack:</h3><p>这道题有两种思路都要学会，官方给的那种方法（第一种方法）更好一些，直接给这两个链接。</p><p>第一种方法：</p><blockquote><p><a href="https://www.52pojie.cn/thread-1048649-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1048649-1-1.html</a></p></blockquote><p>第二种方法：</p><blockquote><p><a href="https://blog.csdn.net/Palmer9/article/details/104119621" target="_blank" rel="noopener">https://blog.csdn.net/Palmer9/article/details/104119621</a></p></blockquote><p>flag脚本在第二种方法里有给</p><h3 id="Classic-CrackMe："><a href="#Classic-CrackMe：" class="headerlink" title="Classic_CrackMe："></a>Classic_CrackMe：</h3><p>放入detectit中查看，这是一道C#的逆向题目。可以用dnspy来反编译看源码。</p><p>进入Form1中看到加密部分，可以看出来是一道AES的加密。</p><p>代码写的很巧妙（太烧脑了不得不说）。</p><p>大概说一下加密的流程，然后可以根据这个流程逆向出来。（他们都问我为什么哭着做题，幼稚园真的太强了）</p><p>你所输入的答案两边会被加上hgame{和}，然后变成新的一个字符串。这个字符串被分成了两部分</p><p>第一部分从第6个字符到第29个字符，第二个部分从第29个字符到第44个字符。</p><p>第一部分被当做aes的iv，第二部分被用作aes2的加密的后半部分。</p><p>text2是”mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=”用aes解密前的明文，text2又是”Same_ciphertext_”</p><p>array是text2+str用aes2加密后的密文的后16个字符也就是后半部分，array同时也是”dJntSWSPWbWocAq4yjBP5Q==”</p><p>下面是官方wp：</p><blockquote><p>输⼊的flflag除去两头之后分成两部分。第⼀部分是⽬标iv，已知密⽂、⽬标明⽂和key，如果直接算会⽐较复杂，但题⽬还有⼀个条件：已知的密⽂是原明⽂⽤原iv加密之后得到的。理解cbc原理之后，我们能得到这个式⼦</p><p><em>中间值的第⼀组 ^ 原iv = 原明⽂的第⼀组</em></p><p><em>中间值的第⼀组 ^ ⽬标iv = ⽬标明⽂的第⼀组</em></p><p><em>⽬标iv = 原iv ^ 原明⽂的第⼀组 ^ ⽬标明⽂的第⼀组</em></p><p>那这个iv就很好求了</p><p>接下来，⽬标明⽂和flflag的第⼆段合并之后⽤原iv加密，对密⽂的后半段进⾏⽐较。结合cbc原理，可以看到第⼆组会与第⼀组密⽂异或，所以只要将第⼀组密⽂作为新的iv，对第⼆组密⽂（后半段密⽂）解密即可 当然第⼀组的密⽂和第⼆组的密⽂拼接在⼀起，然后⽤原iv解密，也是可以的。不过要注意的是，第⼀组明⽂是16字节的，所以单独对它加密时会另padding 16个字节的0x10，因此单独加密时得到的密⽂要切掉后半部分才能和第⼆组密⽂拼接</p><pre><code class="python">import hashlibfrom Crypto.Cipher import AESimport base64class AesCrypter(object): def __init__(self, key, iv):  self.key = key  self.iv = iv def encrypt(self, data):  data = self.pkcs7padding(data)  cipher = AES.new(self.key, AES.MODE_CBC, self.iv)  encrypted = cipher.encrypt(data)  return encrypted def decrypt(self, data):  data = base64.b64decode(data)  cipher = AES.new(self.key, AES.MODE_CBC, self.iv)  decrypted = cipher.decrypt(data)  decrypted = self.pkcs7unpadding(decrypted)  return decrypted def pkcs7padding(self, data):  bs = AES.block_size  padding = bs - len(data) % bs  padding_text = chr(padding) * padding  return data + padding_text def pkcs7unpadding(self, data):  lengt = len(data)  unpadding = ord(data[lengt - 1])  return data[0:lengt-unpadding]if __name__ == &#39;__main__&#39;: key = base64.b64decode(&#39;SGc0bTNfMm8yMF9XZWVLMg==&#39;) OriginalIV = base64.b64decode(&#39;MFB1T2g5SWxYMDU0SWN0cw==&#39;) Part1Plaintext = &#39;Same_ciphertext_&#39; OriginalAes = AesCrypter(key,OriginalIV) OriginalPlain=OriginalAes.decrypt(&#39;mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=&#39;) NewIV = &#39;&#39; for i in range(16):  NewIV +=chr(ord(OriginalPlain[i])^ord(OriginalIV[i])^ord(Part1Plaintext[i])) print &#39;part1: &#39; + NewIV HalfPart2Ciphertext = OriginalAes.encrypt(Part1Plaintext)[0:16] Part2Cipher = HalfPart2Ciphertext +base64.b64decode(&#39;dJntSWSPWbWocAq4yjBP5Q==&#39;) Part2Plaintext = OriginalAes.decrypt(base64.b64encode(Part2Cipher)) print Part2Plaintext print &#39;part2: &#39; + Part2Plaintext[16:] flag = &#39;hgame{&#39; + base64.b64encode(NewIV) + Part2Plaintext[16:] + &#39;}&#39; print flag</code></pre></blockquote><p>这次真的哭了。</p><h3 id="babypy"><a href="#babypy" class="headerlink" title="babypy"></a>babypy</h3><p>这个题目是阅读python的字节码，然后写出python源码，再解密。</p><p>可以看着官方文档来阅读：</p><blockquote><p><a href="https://docs.python.org/3/library/dis.html#python-bytecode-instructions" target="_blank" rel="noopener">https://docs.python.org/3/library/dis.html#python-bytecode-instructions</a></p></blockquote><p>源码如下：</p><pre><code class="python">def encrypt(OOo): O0O = OOo[::-1] O0o = list(O0O) for O0 in range(1, len(O0o)):  Oo = O0o[O0-1] ^ O0o[O0]  O0o[O0] = Oo O = bytes(O0o) return O.hex()</code></pre><p>解密脚本如下：</p><pre><code class="python">a=&quot;\x7d\x03\x7d\x04\x57\x17\x72\x2d\x62\x11\x4e\x6a\x5b\x04\x4f\x2c\x18\x4c\x3f\x44\x21\x4c\x2d\x4a\x22&quot;#print(len(a))b=a[::-1]print(len(b))d=[0 for i in range(0,len(b))]for i in range(0,len(b)-1):    c=ord(b[i])^ord(b[i+1])    d[i]=cprint(d)flag=&#39;&#39;for i in range(0,len(b)):    flag+=chr(d[i])print(flag)</code></pre><h2 id="week3"><a href="#week3" class="headerlink" title="week3:"></a>week3:</h2><h3 id="oooollvm"><a href="#oooollvm" class="headerlink" title="oooollvm:"></a>oooollvm:</h3><p>一道很简单的ollvm题目，根本没进行什么过多的题目，所以整个题目难度很低。</p><p>直接放到ida中，首先先下断点，如图，忽略掉所有的分发器，只要断点下面的有效代码就可以了，这是简单ollvm题目的通用方法：</p><p><img src="https://s2.ax1x.com/2020/02/12/17hHEQ.png" alt></p><p>然后就是动态调试的方法，直到碰到加密的地方为止，函数开始就要求输入34个字符串，然后一直单步到这个位置：</p><p><img src="https://s2.ax1x.com/2020/02/12/174Vv6.png" alt></p><p>直接写脚本跑出来就好了</p><pre><code class="python">table1=[0x22,0xcb,0x7d,0xaf,0x11,0x6f,0x22,0xa9,0xd,0x8e,0x42,0x38,0x1e,0x95,0x40,0x97,0xb4,0xb6,0x31,0xa4,0x4b,0x5,0x62,0x98,0x81,0x9b,0xa9,0x1f,0x63,0x34,0x47,0x80,0x3e,0xb9]table2=[0x4a,0xab,0x1e,0xdf,0x70,0xf,0x47,0xfc,0x79,0xc1,0x1,0x1c,0x43,0xd1,0x63,0xe5,0xf4,0xaa,0x33,0xdb,0x3a,0x62,0x6,0xed,0xec,0xc0,0x9d,0x49,0x5e,0x1c,0x15,0xf3,0x3b,0xa7]s=[]for i in range(34):    for x in range(0,255):        if table2[i]==(x &amp; 0x32AF3201 | ~x &amp; 0xCD50CDFE)^((i+table1[i])&amp;0x32AF3201|~(i+table1[i])&amp;0xCD50CDFE):            s.append(x)print(s)flag=&#39;&#39;for i in range(34):    flag+=chr(s[i])print(flag)</code></pre><p>因为比较简单，本题也就大概说说ollvm的解题原理，以后专门更一个ollvm的解题方法。</p>]]></content>
      
      
      <categories>
          
          <category> re wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UPX </tag>
            
            <tag> dump </tag>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jarvisoj-re-wp</title>
      <link href="/2020/02/05/jarvisoj-re-wp/"/>
      <url>/2020/02/05/jarvisoj-re-wp/</url>
      
        <content type="html"><![CDATA[<h2 id="软件密码破解-1"><a href="#软件密码破解-1" class="headerlink" title="软件密码破解-1"></a>软件密码破解-1</h2><p>放到detectit中查看文件的类型，发现是MFC微软的win32编程，建议od动态调试，放到peid中查询，没有加密函数。</p><p>放到ida中只能看到有一堆的函数，winmain也没有足够的信息。字符串中也没有找到有关flag的字符。只能转战od动态调试。</p><p>在od中右键中文搜索引擎中的智能搜索有意外的发现。</p><p><img src="https://s2.ax1x.com/2020/02/05/1rfKvF.png" alt></p><p>发现了可能有关flag的地方，在这里下一个断点，然后向上寻找线索。</p><p><img src="https://s2.ax1x.com/2020/02/05/1rfXMF.png" alt></p><p>这时候需要运行然后顺着断点的地方向上找到输入的地方，在这里</p><p><img src="https://s2.ax1x.com/2020/02/05/1r5mCt.png" alt></p><p>解读下上面的汇编，输入的地址放入了ebx中，ptr ds:[ebx]可以调用你输入的字符串，然后把ebx赋给eax,重点是60到67的循环，用ptr ds:[ecx+eax]的字符串放到dl中（查看ptr ds:[eax+ecx]的方法是先把鼠标放到你要查的位置上然后右键数据窗口中跟随，选择内存地址便可以再左下角的内存窗口上查看），然后让dl与ptr ds:[eax]的字符串进行异或，eax刚才被ebx赋值了，也就是说ptr ds:[eax]就是你所输入的字符串，它与系统中的某组字符串进行了异或。再往下有几个cmp的比较，是用你输入的经过异或变换的字符串与所显示的字符串进行比较，这些所显示出来的数字因为是小端序排列的所以，要进行变换顺序才能进行正常比较（写脚本的时候注意）。</p><p>脚本如下：</p><pre><code class="python">flag=&#39;&#39;a=[0x28,0x57,0x64,0x6b,0x93,0x8f,0x65,0x51,0xe3,0x53,0xe4,0x4e,0x1a,0xff]b=[0x1b,0x1c,0x17,0x46,0xf4,0xfd,0x20,0x30,0xb7,0xc,0x8e,0x7e,0x78,0xde]for i in range(len(a)):    flag+=chr(a[i]^b[i])print(flag)</code></pre><p>flag是3Ks-grEaT_j0b!</p><h2 id="findkey"><a href="#findkey" class="headerlink" title="findkey"></a>findkey</h2><p>这是一个pyc文件是由python语言写成的，直接使用python在线反编译就可以看到源码，由于结构太简单了就不贴了，方法是脚本爆破，直接上脚本就好了：</p><pre><code class="python">lookup = [    196,    153,    149,    206,    17,    221,    10,    217,    167,    18,    36,    135,    103,    61,    111,    31,    92,    152,    21,    228,    105,    191,    173,    41,    2,    245,    23,    144,    1,    246,    89,    178,    182,    119,    38,    85,    48,    226,    165,    241,    166,    214,    71,    90,    151,    3,    109,    169,    150,    224,    69,    156,    158,    57,    181,    29,    200,    37,    51,    252,    227,    93,    65,    82,    66,    80,    170,    77,    49,    177,    81,    94,    202,    107,    25,    73,    148,    98,    129,    231,    212,    14,    84,    121,    174,    171,    64,    180,    233,    74,    140,    242,    75,    104,    253,    44,    39,    87,    86,    27,    68,    22,    55,    76,    35,    248,    96,    5,    56,    20,    161,    213,    238,    220,    72,    100,    247,    8,    63,    249,    145,    243,    155,    222,    122,    32,    43,    186,    0,    102,    216,    126,    15,    42,    115,    138,    240,    147,    229,    204,    117,    223,    141,    159,    131,    232,    124,    254,    60,    116,    46,    113,    79,    16,    128,    6,    251,    40,    205,    137,    199,    83,    54,    188,    19,    184,    201,    110,    255,    26,    91,    211,    132,    160,    168,    154,    185,    183,    244,    78,    33,    123,    28,    59,    12,    210,    218,    47,    163,    215,    209,    108,    235,    237,    118,    101,    24,    234,    106,    143,    88,    9,    136,    95,    30,    193,    176,    225,    198,    197,    194,    239,    134,    162,    192,    11,    70,    58,    187,    50,    67,    236,    230,    13,    99,    190,    208,    207,    7,    53,    219,    203,    62,    114,    127,    125,    164,    179,    175,    112,    172,    250,    133,    130,    52,    189,    97,    146,    34,    157,    120,    195,    45,    4,    142,    139]pwda = [    188,    155,    11,    58,    251,    208,    204,    202,    150,    120,    206,    237,    114,    92,    126,    6,    42]pwdb = [    53,    222,    230,    35,    67,    248,    226,    216,    17,    209,    32,    2,    181,    200,    171,    60,    108]flag=&#39;&#39;for i in range(0,17):    for x in range(0,255):        if (x + pwda[i] &amp; 255) == lookup[i+pwdb[i]]:            flag+=chr(x)flag=flag[::-1]print(flag)</code></pre>]]></content>
      
      
      <categories>
          
          <category> re wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AES加密学习</title>
      <link href="/2020/02/01/AES%E5%8A%A0%E5%AF%86%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/02/01/AES%E5%8A%A0%E5%AF%86%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="AES原理"><a href="#AES原理" class="headerlink" title="AES原理:"></a>AES原理:</h3><blockquote><p><a href="https://blog.csdn.net/gulang03/article/details/81175854" target="_blank" rel="noopener">https://blog.csdn.net/gulang03/article/details/81175854</a></p></blockquote><h3 id="AES的四种模式"><a href="#AES的四种模式" class="headerlink" title="AES的四种模式:"></a>AES的四种模式:</h3><blockquote><p><a href="https://www.cnblogs.com/liangxuehui/p/4651351.html" target="_blank" rel="noopener">https://www.cnblogs.com/liangxuehui/p/4651351.html</a></p></blockquote><h3 id="AES的算法代码"><a href="#AES的算法代码" class="headerlink" title="AES的算法代码:"></a>AES的算法代码:</h3><blockquote><p><a href="https://blog.csdn.net/shaosunrise/article/details/80219950" target="_blank" rel="noopener">https://blog.csdn.net/shaosunrise/article/details/80219950</a></p></blockquote><p>感觉这几篇说的都很详细，网上的关于AES的介绍都挺清晰，都可以用来学习。</p>]]></content>
      
      
      <categories>
          
          <category> crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxtea学习</title>
      <link href="/2020/01/29/xxtea%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/01/29/xxtea%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>大概介绍一下xxtea的原理，发现最近re的题目很喜欢出</p><p>原理图如下：</p><p><img src="https://s2.ax1x.com/2020/01/29/1Q2JET.png" alt></p><p>加密解密代码如下：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define DELTA 0x9e3779b9#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))void btea(uint32_t *v, int n, uint32_t const key[4]){    uint32_t y, z, sum;    unsigned p, rounds, e;    if (n &gt; 1)            /* Coding Part */    {        rounds = 6 + 52/n;        sum = 0;        z = v[n-1];        do        {            sum += DELTA;            e = (sum &gt;&gt; 2) &amp; 3;            for (p=0; p&lt;n-1; p++)            {                y = v[p+1];                z = v[p] += MX;            }            y = v[0];            z = v[n-1] += MX;        }        while (--rounds);    }    else if (n &lt; -1)      /* Decoding Part */    {        n = -n;        rounds = 6 + 52/n;        sum = rounds*DELTA;        y = v[0];        do        {            e = (sum &gt;&gt; 2) &amp; 3;            for (p=n-1; p&gt;0; p--)            {                z = v[p-1];                y = v[p] -= MX;            }            z = v[n-1];            y = v[0] -= MX;            sum -= DELTA;        }        while (--rounds);    }}int main(){    uint32_t v[2]= {1,2};    uint32_t const k[4]= {2,2,3,4};    int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密    // v为要加密的数据是两个32位无符号整数    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位    printf(&quot;加密前原始数据：%u %u\n&quot;,v[0],v[1]);    btea(v, n, k);    printf(&quot;加密后的数据：%u %u\n&quot;,v[0],v[1]);    btea(v, -n, k);    printf(&quot;解密后的数据：%u %u\n&quot;,v[0],v[1]);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RSA密码学习</title>
      <link href="/2020/01/16/RSA%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/01/16/RSA%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="center">步骤</th><th align="center">描述</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">找出两个质数</td><td align="center">P,Q</td><td align="center"></td></tr><tr><td align="center">计算公共模数</td><td align="center">N=P*Q</td><td align="center"></td></tr><tr><td align="center">欧拉函数</td><td align="center">φ(N)=(P-1)(Q-1)</td><td align="center"></td></tr><tr><td align="center">计算公钥E</td><td align="center">1&lt;E&lt;φ(N)</td><td align="center">E的取值必须是整数   E和φ(N)必须是互质数</td></tr><tr><td align="center">计算私钥D</td><td align="center">E*D%φ(N)=1</td><td align="center"></td></tr><tr><td align="center">加密</td><td align="center">C=M的E次方 mod N</td><td align="center">C：密文 M：明文</td></tr><tr><td align="center">解密</td><td align="center">M=C的D次方 mod N</td><td align="center">C：密文 M：明文</td></tr></tbody></table><p>公钥=(E,N)</p><p>私钥=(D,N)</p><p>解密</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="1，找出质数P-Q"><a href="#1，找出质数P-Q" class="headerlink" title="1，找出质数P,Q"></a>1，找出质数P,Q</h4><p>$$<br>P=3<br>$$</p><p>$$<br>Q=11<br>$$</p><h4 id="2，计算公共模数"><a href="#2，计算公共模数" class="headerlink" title="2，计算公共模数"></a>2，计算公共模数</h4><p>$$<br>N=P<em>Q=3</em>11=33<br>$$</p><h4 id="3，欧拉函数"><a href="#3，欧拉函数" class="headerlink" title="3，欧拉函数"></a>3，欧拉函数</h4><p>$$<br>φ(N) = (P-1)(Q-1) = 2 * 10 = 20<br>$$</p><h4 id="4，计算公钥E"><a href="#4，计算公钥E" class="headerlink" title="4，计算公钥E"></a>4，计算公钥E</h4><p>$$<br>1 &lt; E &lt; φ(N)<br>$$</p><p>$$<br>1 &lt;E &lt; 20<br>$$</p><blockquote><p>E 的取值范围 {3, 7, 9, 11, 13, 17, 19}<br>E的取值必须是整数, E 和 φ(N) 必须是互质数<br>为了测试，我们取最小的值 <strong>E =3</strong><br>3 和 φ(N) =20 互为质数，满足条件</p></blockquote><h4 id="5，计算私钥D"><a href="#5，计算私钥D" class="headerlink" title="5，计算私钥D"></a>5，计算私钥D</h4><p>$$<br>E * D mod φ(N) = 1<br>$$</p><p>$$<br>3 * D  mod 20 = 1<br>$$</p><h4 id="6，公钥加密"><a href="#6，公钥加密" class="headerlink" title="6，公钥加密"></a>6，公钥加密</h4><p><img src="https://s2.ax1x.com/2020/01/16/lj5Cee.png" alt="加密"></p><blockquote><p>M = 2 </p><p>E = 3 </p><p>N = 33</p></blockquote><blockquote><p>C = 8</p></blockquote><h4 id="7，私钥解密"><a href="#7，私钥解密" class="headerlink" title="7，私钥解密"></a>7，私钥解密</h4><p><img src="https://s2.ax1x.com/2020/01/16/lj5PdH.png" alt="解密"></p><blockquote><p>C = 8</p><p>D = 7</p><p>N = 33</p></blockquote><blockquote><p>M = 2</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>花指令学习</title>
      <link href="/2020/01/14/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/01/14/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在原来的汇编程序中加入一些干扰阅读的代码，这些代码可以看做是花指令。</p><p>这类题在ctf中很常见，但是要多加练习。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>总体上花指令分为两类，一类是可履行式花指令，另一类为不可履行式花指令（废物指令）。</p><p>对于可履行式花指令，望文生义就是能够正常运转的但又不改动原始程序逻辑性的一组无用指令。这类花指令有如下特色：</p><p>①能够正常运转；</p><p>②不改动任何寄存器的值；</p><p>③反汇编器能够正确反汇编该指令。</p><p>对于不可履行式花指令，是指被刺进到原始代码中但又不改动原始程序逻辑性的一组无用字节。这类花指令有如下特色：</p><p>①不行以正常运转；</p><p>②不改动任何寄存器的值；</p><p>③反汇编器或许会过错反汇编这些字节。</p><h3 id="花指令的经典模型"><a href="#花指令的经典模型" class="headerlink" title="花指令的经典模型"></a>花指令的经典模型</h3><h4 id="1-伪装-vc"><a href="#1-伪装-vc" class="headerlink" title="1.伪装 vc"></a>1.伪装 vc</h4><p><code>VC++程序的入口代码:</code></p><p><code>PUSH EBP</code></p><p><code>MOV EBP,ESP</code></p><p><code>PUSH -1</code></p><p><code>push 415448 -\___</code></p><p><code>PUSH 4021A8 // 在这段代码中类似这样的[操作数](https://baike.baidu.com/item/操作数)可以乱填</code></p><p><code>MOV EAX,DWORD PTR FS:[0]</code></p><p><code>PUSH EAX</code></p><p><code>MOV DWORD PTR FS:[0],ESP</code></p><p><code>ADD ESP,-6C</code></p><p><code>PUSH EBX</code></p><p><code>PUSH ESI</code></p><p><code>PUSH EDI</code></p><p><code>ADD BYTE PTR DS:[EAX],AL //这条指令可以不要!</code></p><p><code>jmp 跳转到程序原来的入口点</code></p><h4 id="2-跳转"><a href="#2-跳转" class="headerlink" title="2.跳转"></a>2.跳转</h4><p><code>somewhere:</code><br><code>nop //&quot;胡乱&quot;跳转的开始...</code><br><code>jmp 下一个jmp的地址 /在附近随意跳</code><br><code>jmp ... //...</code><br><code>jmp 原入口的地址 //跳到原始oep</code></p><hr><p><code>新入口: push ebp</code></p><p><code>mov ebp,esp</code></p><p><code>inc ecx</code></p><p><code>push edx</code></p><p><code>nop</code></p><p><code>pop edx</code></p><p><code>dec ecx</code></p><p><code>pop ebp</code></p><p><code>inc ecx</code></p><p><code>loop somewhere //跳转到上面那段代码地址去！</code></p><h4 id="3-伪装c"><a href="#3-伪装c" class="headerlink" title="3.伪装c"></a>3.伪装c</h4><p><code>融合</code></p><p><code>把A的代码换成B的</code></p><p><code>push ebp</code></p><p><code>mov ebp,esp</code></p><p><code>push -1</code></p><p><code>push 111111</code></p><p><code>push 222222</code></p><p><code>mov eax,fs:[0]</code></p><p><code>push eax</code></p><p><code>mov fs:[0],esp</code></p><p><code>pop eax</code></p><p><code>mov fs:[0],eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>mov ebp,eax</code></p><p><code>jmp 老入口</code></p><h4 id="4-c"><a href="#4-c" class="headerlink" title="4.c ++"></a>4.c ++</h4><p><code>push ebp</code></p><p><code>mov ebp,esp</code></p><p><code>push -1</code></p><p><code>push 111111</code></p><p><code>push 222222</code></p><p><code>mov eax,fs:[0]</code></p><p><code>push eax</code></p><p><code>mov fs:[0],esp</code></p><p><code>pop eax</code></p><p><code>mov fs:[0],eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>mov ebp,eax</code></p><h4 id="5-Microsoft-Visual-C-6-0"><a href="#5-Microsoft-Visual-C-6-0" class="headerlink" title="5.Microsoft Visual C++ 6.0"></a>5.Microsoft Visual C++ 6.0</h4><p><code>PUSH -1</code></p><p><code>PUSH 0</code></p><p><code>PUSH 0</code></p><p><code>MOV EAX,DWORD PTR FS:[0]</code></p><p><code>PUSH EAX</code></p><p><code>MOV DWORD PTR FS:[0],ESP</code></p><p><code>SUB ESP,68</code></p><p><code>PUSH EBX</code></p><p><code>PUSH ESI</code></p><p><code>PUSH EDI</code></p><p><code>POP EAX</code></p><p><code>POP EAX</code></p><p><code>POP EAX</code></p><p><code>ADD ESP,68</code></p><p><code>POP EAX</code></p><p><code>MOV DWORD PTR FS:[0],EAX</code></p><p><code>POP EAX</code></p><p><code>POP EAX</code></p><p><code>POP EAX</code></p><p><code>POP EAX</code></p><p><code>MOV EBP,EAX</code></p><p><code>JMP 原入口</code></p><h4 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h4><p><code>在mov ebp,eax</code></p><p><code>后面加上</code></p><p><code>PUSH EAX</code></p><p><code>POP EAX</code></p><h4 id="7-防杀精灵一号防杀代码"><a href="#7-防杀精灵一号防杀代码" class="headerlink" title="7.防杀精灵一号防杀代码"></a>7.防杀精灵一号防杀代码</h4><p><code>push ebp</code></p><p><code>mov ebp,esp</code></p><p><code>push -1</code></p><p><code>push 666666</code></p><p><code>push 888888</code></p><p><code>mov eax,dword ptr fs:[0]</code></p><p><code>push eax</code></p><p><code>mov dword ptr fs:[0],esp</code></p><p><code>pop eax</code></p><p><code>mov dword ptr fs:[0],eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>mov ebp,eax</code></p><p><code>jmp 入口</code></p><h4 id="8-防杀精灵二号防杀代码"><a href="#8-防杀精灵二号防杀代码" class="headerlink" title="8.防杀精灵二号防杀代码"></a>8.防杀精灵二号防杀代码</h4><p><code>push ebp</code></p><p><code>mov ebp,esp</code></p><p><code>push -1</code></p><p><code>push 0</code></p><p><code>push 0</code></p><p><code>mov eax,dword ptr fs:[0]</code></p><p><code>push eax</code></p><p><code>mov dword ptr fs:[0],esp</code></p><p><code>sub esp,68</code></p><p><code>push ebx</code></p><p><code>push esi</code></p><p><code>push edi</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>add esp,68</code></p><p><code>pop eax</code></p><p><code>mov dword ptr fs:[0],eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>mov ebp,eax</code></p><p><code>jmp 入口</code></p><h4 id="9-防杀精灵终极防杀代码"><a href="#9-防杀精灵终极防杀代码" class="headerlink" title="9.防杀精灵终极防杀代码"></a>9.防杀精灵终极防杀代码</h4><p><code>push ebp</code></p><p><code>mov ebp,esp</code></p><p><code>add esp,-0C</code></p><p><code>add esp,0C</code></p><p><code>push eax</code></p><p><code>jmp入口</code></p><h4 id="10-木马彩衣-金色鱼锦衣-花代码"><a href="#10-木马彩衣-金色鱼锦衣-花代码" class="headerlink" title="10.木马彩衣(金色鱼锦衣)花代码"></a>10.木马彩衣(金色鱼锦衣)花代码</h4><p><code>push ebp</code></p><p><code>mov ebp,esp</code></p><p><code>add esp,-0C</code></p><p><code>add esp,0C</code></p><p><code>mov eax,原入口</code></p><p><code>push eax</code></p><p><code>retn</code></p><h4 id="11-木马彩衣-虾米披风-花代码"><a href="#11-木马彩衣-虾米披风-花代码" class="headerlink" title="11.木马彩衣(虾米披风)花代码"></a>11.木马彩衣(虾米披风)花代码</h4><p><code>push ebp</code></p><p><code>nop</code></p><p><code>nop</code></p><p><code>mov ebp,esp</code></p><p><code>inc ecx</code></p><p><code>nop</code></p><p><code>push edx</code></p><p><code>nop</code></p><p><code>nop</code></p><p><code>pop edx</code></p><p><code>nop</code></p><p><code>pop ebp</code></p><p><code>inc ecx</code></p><p><code>loopd //跳转到下面那段代码地址去！</code></p><hr><p><code>nop //&quot;胡乱&quot;跳转的开始...</code></p><p><code>jmp 下一个jmp的地址 //在附近随意跳</code></p><p><code>jmp ... //...</code></p><p><code>jmp 原入口的地址 //跳到原始oep</code></p><h4 id="12-VC-5-0代码-木马彩衣无限复活袍"><a href="#12-VC-5-0代码-木马彩衣无限复活袍" class="headerlink" title="12.VC++5.0代码(木马彩衣无限复活袍):"></a>12.VC++5.0代码(木马彩衣无限复活袍):</h4><p><code>PUSH EBP</code></p><p><code>MOV EBP,ESP</code></p><p><code>PUSH -1</code></p><p><code>push 415448 -\___</code></p><p><code>PUSH 4021A8 -// 在这段代码中类似这样的操作数可以乱填</code></p><p><code>MOV EAX,DWORD PTR FS:[0]</code></p><p><code>PUSH EAX</code></p><p><code>MOV DWORD PTR FS:[0],ESP</code></p><p><code>ADD ESP,-6C</code></p><p><code>PUSH EBX</code></p><p><code>PUSH ESI</code></p><p><code>PUSH EDI</code></p><p><code>ADD BYTE PTR DS:[EAX],AL //这条指令可以不要!</code></p><p><code>jo 00401000 //原入口</code></p><p><code>jno 00401000 //原入口</code></p><p><code>db 0e8h //花代码</code></p>]]></content>
      
      
      <categories>
          
          <category> 逆向工程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>rc4学习</title>
      <link href="/2019/11/29/rc4%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/11/29/rc4%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>RC4是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。RC4是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。<br>流密码结构：<br><img src="https://s2.ax1x.com/2019/11/29/QkXROO.png" alt></p><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><p>下面这个图是rc4的流程图：<br><img src="https://s2.ax1x.com/2019/11/29/QkXj0g.png" alt><br>1、先初始化状态向量S（256个字节，用来作为密钥流生成的种子1）</p><p>按照升序，给每个字节赋值0,1,2,3,4,5,6…..,254,255</p><p>2、初始密钥（由用户输入），长度任意</p><p>如果输入长度小于256个字节，则进行轮转，直到填满</p><p>例如输入密钥的是1,2,3,4,5   ,  那么填入的是1,2,3,4,5,1,2,3,4,5,1,2,3,4,5……..</p><p>由上述轮转过程得到256个字节的向量T（用来作为密钥流生成的种子2）</p><p>3、开始对状态向量S进行置换操作（用来打乱初始种子1）</p><p>按照下列规则进行</p><p>从第零个字节开始，执行256次，保证每个字节都得到处理</p><pre><code class="c">j = 0;for (i = 0 ; i &lt; 256 ; i++){j = (j + S[i] + T[i]) mod 256;swap(S[i] , S[j]);}</code></pre><p>这样处理后的状态向量S几乎是带有一定的随机性了<br>4、最后是秘钥流的生成与加密，很多人在这里不是特别理解，别的博客也没有写的很简洁明了</p><p>假设我的明文字节数是datalength=1024个字节（当然可以是任意个字节）</p><p>i=0;</p><p>j=0;</p><p>while(datalength–){//相当于执行1024次，这样生成的秘钥流也是1024个字节</p><p>　　</p><pre><code class="c">i = (i + 1) mod 256;j = (j + S[i]) mod 256;swap(S[i] , S[j]);t = (S[i] + S[j]) mod 256;k = S[t];这里的K就是当前生成的一个秘钥流中的一位</code></pre><p>　　　　//可以直接在这里进行加密，当然也可以将密钥流保存在数组中，最后进行异或就ok</p><pre><code class="c">data[]=data[]^k； //进行加密，&quot;^&quot;是异或运算符</code></pre><p>}</p><p>解密按照前面写的，异或两次就是原文，所以只要把密钥流重新拿过来异或一次就能得到原文了</p><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><p>RC4算法的原理很简单，包括初始化算法（KSA）和伪随机子密码生成算法（PRGA)两大部分。假设S-box的长度为256，密钥长度为Len。先来看看算法的初始化部分（用C代码表示）： [1]<br>其中，参数1是一个256长度的char型数组，定义为: unsigned char sBox[256];<br>参数2是密钥，其内容可以随便定义：char key[256];<br>参数3是密钥的长度，Len = strlen(key);</p><pre><code class="c">/*初始化函数*/void rc4_init(unsigned char*s,unsigned char*key, unsigned long Len){    int i=0,j=0;    //char k[256]={0};    unsigned char k[256]={0};    unsigned char tmp=0;    for(i=0;i&lt;256;i++) {        s[i]=i;        k[i]=key[i%Len];    }    for(i=0;i&lt;256;i++) {        j=(j+s[i]+k[i])%256;        tmp=s[i];        printf(&quot;copy for dongdeng&quot;);        s[i]=s[j];//交换s[i]和s[j]        s[j]=tmp;    }}</code></pre><p>在初始化的过程中，密钥的主要功能是将S-box搅乱，i确保S-box的每个元素都得到处理，j保证S-box的搅乱是随机的。而不同的S-box在经过伪随机子密码生成算法的处理后可以得到不同的子密钥序列，将S-box和明文进行xor运算，得到密文，解密过程也完全相同。<br>再来看看算法的加密部分（用C代码表示）：<br>其中，参数1是上边rc4_init函数中，被搅乱的S-box;<br>参数2是需要加密的数据data;<br>参数3是data的长度.</p><pre><code class="c">/*加解密*/void rc4_crypt(unsigned char*s,unsigned char*Data,unsigned long Len){    int i=0,j=0,t=0;    unsigned long k=0;    unsigned char tmp;    for(k=0;k&lt;Len;k++)    {        i=(i+1)%256;        j=(j+s[i])%256;        tmp=s[i];        s[i]=s[j];//交换s[x]和s[y]        s[j]=tmp;        t=(s[i]+s[j])%256;        Data[k]^=s[t];    }}</code></pre><p>最后，在main函数中，调用顺序如下：</p><pre><code class="c">int main(){unsigned char s[256]={0},s2[256]={0};//S-boxchar key[256]={&quot;justfortest&quot;};char pData[512]=&quot;这是一个用来加密的数据Data&quot;;unsigned long len=strlen(pData);int i;printf(&quot;pData=%s\n&quot;,pData);printf(&quot;key=%s,length=%d\n\n&quot;,key,strlen(key));rc4_init(s,(unsigned char*)key,strlen(key));//已经完成了初始化printf(&quot;完成对S[i]的初始化，如下：\n\n&quot;);for(i=0;i&lt;256;i++){    printf(&quot;%02X&quot;,s[i]);    if(i&amp;&amp;(i+1)%16==0)putchar(&#39;\n&#39;);}printf(&quot;\n\n&quot;);for(i=0;i&lt;256;i++)//用s2[i]暂时保留经过初始化的s[i]，很重要的！！！{    s2[i]=s[i];}printf(&quot;已经初始化，现在加密:\n\n&quot;);rc4_crypt(s,(unsigned char*)pData,len);//加密printf(&quot;pData=%s\n\n&quot;,pData);printf(&quot;已经加密，现在解密:\n\n&quot;);//rc4_init(s,(unsigned char*)key,strlen(key));//初始化密钥rc4_crypt(s2,(unsigned char*)pData,len);//解密printf(&quot;pData=%s\n\n&quot;,pData);return0;}</code></pre><p>最终的完整程序是：</p><pre><code class="c">//程序开始#include&lt;stdio.h&gt;#include&lt;string.h&gt;typedef unsigned longULONG; /*初始化函数*/void rc4_init(unsigned char*s, unsigned char*key, unsigned long Len){    int i = 0, j = 0;    char k[256] = { 0 };    unsigned char tmp = 0;    for (i = 0; i&lt;256; i++)    {        s[i] = i;        k[i] = key[i%Len];    }    for (i = 0; i&lt;256; i++)    {        j = (j + s[i] + k[i]) % 256;        tmp = s[i];        s[i] = s[j];//交换s[i]和s[j]        s[j] = tmp;    }}/*加解密*/void rc4_crypt(unsigned char*s, unsigned char*Data, unsigned long Len){    int i = 0, j = 0, t = 0;    unsigned long k = 0;    unsigned char tmp;    for (k = 0; k&lt;Len; k++)    {        i = (i + 1) % 256;        j = (j + s[i]) % 256;        tmp = s[i];        s[i] = s[j];//交换s[x]和s[y]        s[j] = tmp;        t = (s[i] + s[j]) % 256;        Data[k] ^= s[t];    }}int main(){    unsigned char s[256] = { 0 }, s2[256] = { 0 };//S-box    char key[256] = { &quot;justfortest&quot; };    char pData[512] = &quot;这是一个用来加密的数据Data&quot;;    unsigned long len = strlen(pData);    int i;         printf(&quot;pData=%s\n&quot;, pData);    printf(&quot;key=%s,length=%d\n\n&quot;, key, strlen(key));    rc4_init(s, (unsigned char*)key, strlen(key));//已经完成了初始化    printf(&quot;完成对S[i]的初始化，如下：\n\n&quot;);    for (i = 0; i&lt;256; i++)    {        printf(&quot;%02X&quot;, s[i]);        if (i &amp;&amp; (i + 1) % 16 == 0)putchar(&#39;\n&#39;);    }    printf(&quot;\n\n&quot;);    for (i = 0; i&lt;256; i++)//用s2[i]暂时保留经过初始化的s[i]，很重要的！！！    {        s2[i] = s[i];    }    printf(&quot;已经初始化，现在加密:\n\n&quot;);    rc4_crypt(s, (unsigned char*)pData, len);//加密    printf(&quot;pData=%s\n\n&quot;, pData);    printf(&quot;已经加密，现在解密:\n\n&quot;);    //rc4_init(s,(unsignedchar*)key,strlen(key));//初始化密钥    rc4_crypt(s2, (unsigned char*)pData, len);//解密    printf(&quot;pData=%s\n\n&quot;, pData);    return 0;}//程序完</code></pre>]]></content>
      
      
      <categories>
          
          <category> crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019 nctf wp</title>
      <link href="/2019/11/29/2019-nctf-wp/"/>
      <url>/2019/11/29/2019-nctf-wp/</url>
      
        <content type="html"><![CDATA[<h1 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h1><p>动态调试即可，发现函数最后要和s比较，s经过多次加密。<br><img src="https://s2.ax1x.com/2019/11/29/Qkh1IO.png" alt><br>上图cmp dl,al就是比较过程.<br>动态调试看寄存中的值就可以得到flag。<br>本道题有一个值得学习的算法在rc4上</p><blockquote><p><a href="https://odoiys.github.io/2019/11/29/rc4%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener" title="rc4学习">https://odoiys.github.io/2019/11/29/rc4%E5%AD%A6%E4%B9%A0/</a></p></blockquote><h1 id="签到题"><a href="#签到题" class="headerlink" title="签到题"></a>签到题</h1><p>使用z3求解器</p><pre><code>from z3 import *a = [12, 83, 78, 39, 23, 27, 4, 53, 85, 53, 78, 6, 85, 6, 6, 12, 24, 52, 14, 92, 3, 34, 73, 36, 9, 74, 42, 67, 58, 27, 86, 62, 48, 48, 0, 36, 96, 25, 37, 12, 15, 26, 1, 52, 46, 84, 83, 72, 68]b = [18564,37316,32053,33278,23993,33151,15248,13719,34137,27391,28639,18453,28465,12384,20780,45085,35827,37243,26037,39409,17583,20825,44474,35138,36914,25918,38915,17672,21219,43935,37072,39359,27793,41447,18098,21335,46164,38698,39084,29205,40913,19117,21786,46573,38322,41017,29298,43409,19655]s = Solver()key = [BitVec(&#39;u%d&#39;%i,8) for i in range(49)]for i in range(7):    for j in range(7):        s.add(b[i*7+j] == key[i*7]*a[j]+key[i*7+1]*a[7*1+j]+key[i*7+2]*a[7*2+j]+key[i*7+3]*a[7*3+j]+key[i*7+4]*a[7*4+j]+key[i*7+5]*a[7*5+j]+key[i*7+6]*a[7*6+j])flag = &#39;&#39;if s.check() == sat:    result = s.model()    for i in range(49):        flag += chr(result[key[i]].as_long().real)    print flag</code></pre><p>z3有问题可以看这个链接<br><a href="https://ericpony.github.io/z3py-tutorial/guide-examples.htm" target="_blank" rel="noopener" title="z3求解器手册">https://ericpony.github.io/z3py-tutorial/guide-examples.htm</a></p>]]></content>
      
      
      <categories>
          
          <category> re wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019 赛博ctf wp</title>
      <link href="/2019/11/13/2019-%E8%B5%9B%E5%8D%9Actf-wp/"/>
      <url>/2019/11/13/2019-%E8%B5%9B%E5%8D%9Actf-wp/</url>
      
        <content type="html"><![CDATA[<h1 id="TEA"><a href="#TEA" class="headerlink" title="TEA"></a>TEA</h1><p>放到detectit看一下文件<br><img src="https://s2.ax1x.com/2019/11/13/MJof2R.png" alt><br>MFC类型</p><blockquote><p>微软基础类库（英语：Microsoft Foundation Classes，简称MFC）是微软公司提供的一个类库（class libraries），以C++类的形式封装了Windows API，并且包含一个应用程序框架，以减少应用程序开发人员的工作量。其中包含大量Windows句柄封装类和很多Windows的内建控件和组件的封装类。</p></blockquote><p>直接查看字符串<br><img src="https://s2.ax1x.com/2019/11/13/MJTZMq.png" alt><br>看到一个 flag正确<br>可以选择直接过去查看函数<br>F5直接看伪代码<br><img src="https://s2.ax1x.com/2019/11/13/MJTxfJ.png" alt><br>上图是该段代码最重要的部分<br>在这里，应该学习一下，这个是tea密码<br>（有空再来更新一下tea密码，电脑快没电了，逃<br>最后要和程序里的代码比较一下<br>最后贴上解密代码</p><p>`#include&lt;stdio.h&gt;<br>void decrypt(unsigned int <em>v, unsigned int *k)<br>{<br>    unsigned int v0 = v[0], v1 = v[1], sum = 0xc6ef3720, i;<br>    unsigned int delta = 0x9e3779b9;<br>    unsigned int k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];<br>    for (i = 0;i &lt; 32;i++)<br>    {<br>        v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3);<br>        v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1);<br>        sum -= delta;<br>    }<br>    v[0] = v0;<br>    v[1] = v1;<br>}<br>int main()<br>{<br>    unsigned int key[4] = { 1634103412,825438253,792290103,593654333 };<br>    unsigned int fis[8] = { 2287891615,1585311399,1546078125,467622186,705539630,739426750,3404744146,2450907267 };<br>    int j;<br>    for (j = 0; j &lt; 4; j++)<br>    {<br>        decrypt(&amp;fis[j * 2], key);<br>    }<br>    int i;<br>    for (i = 0; i &lt; 32; i++)<br>    {<br>        printf(“%c”, *(((char</em>)fis) + i));<br>    }<br>        system(“pause”);</p><p>}`</p><p>(有空更新一下pyhton的解密代码吧，这里先把ctfwiki上介绍的tea贴上去<br><a href="https://ctf-wiki.github.io/ctf-wiki/reverse/Identify-Encode-Encryption/introduction-zh/" target="_blank" rel="noopener" title="ctfwiki">https://ctf-wiki.github.io/ctf-wiki/reverse/Identify-Encode-Encryption/introduction-zh/</a></p><h1 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h1><p>放到detectit,如下：<br><img src="https://s2.ax1x.com/2019/11/14/MtLJat.png" alt><br>先查看主函数里的内容<br><img src="https://s2.ax1x.com/2019/11/14/MtLRRU.png" alt><br>需要仔细研究的函数有checktime(),check(&amp;s),run(&amp;s),key(&amp;s,90)应该是对字符串的输入<br>先来查看checktime()<br><img src="https://s2.ax1x.com/2019/11/14/MtOPFP.png" alt><br>这个应该算是方程组的求解可以算出来对应的值（要用线代，但也可以不用，建议尝试z3求解器，真的是神器）<br>看一下求解的代码</p><pre><code>from z3 import *solver = Solver()v4 = Int(&#39;v4&#39;)v5 = Int(&#39;v5&#39;)v6 = Int(&#39;v6&#39;)v7 = Int(&#39;v7&#39;)v8 = Int(&#39;v8&#39;)v9 = Int(&#39;v9&#39;)v10 = Int(&#39;v10&#39;)v11 = Int(&#39;v11&#39;)solver.add(14766 * v10 + 18242 * v9 + 4657 * v8 + 22453 * v7 + 7236 * v6 + 28554 * v5 + 25606 * v4 + 12289 * v11 == 12977737)solver.add(27429 * v10 + 8015 * v9 + 16511 * v8 + 17180 * v7 + 27141 * v6 + 31813 * v5 + 7412 * v4 + 18249 * v11 == 15081473)solver.add(2846 * v10 + 28353 * v9 + 19864 * v8 + 27377 * v7 + 9006 * v6 + 13657 * v5 + 19099 * v4 + 25835 * v11 == 13554960)solver.add(1078 * v10 + 5007 * v9 + 6568 * v8 + 23034 * v7 + 10150 * v6 + 22949 * v5 + 32646 * v4 + 15255 * v11 == 11284005)solver.add(8010 * v10 + 15430 * v9 + 6657 * v8 + 1009 * v7 + 25691 * v6 + 15960 * v5 + 19493 * v4 + 29491 * v11 == 10759932)solver.add(4605 * v10 + 14468 * v9 + 5017 * v8 + 12805 * v7 + 22973 * v6 + 30584 * v5 + 12620 * v4 + 32085 * v11 == 12085266)solver.add(7478 * v10 + 6524 * v9 + 25994 * v8 + 16215 * v7 + 12864 * v6 + 20574 * v5 + 8882 * v4 + 14794 * v11 == 11323393)solver.add(15263 * v10 + 8821 * v9 + 25489 * v8 + 9598 * v7 + 26847 * v6 + 5175 * v5 + 6515 * v4 + 27411 * v11 == 11677607)if solver.check() == sat:    m = solver.model()    print(m)</code></pre><p>算出来的答案<br>v6 = 97<br>v5 = 108<br>v7 = 103<br>v4 = 102<br>v8 = 123<br>v10 = 104<br>v11 = 51<br>v9 = 84<br>可以转成字符串先看一下，flag{Th3，应该是flag的前几位</p><blockquote><p>这里也咕咕一下，留空准备介绍下z3的学习</p></blockquote><p>再来看一下check(&amp;s)函数<br><img src="https://s2.ax1x.com/2019/11/14/MtXHgO.png" alt><br>这个算法必须看会，这个类似base64编码，这个是base58（可我为什么感觉这两编码的代码差别好大，看来要学习一下了）<br>可以用网上的base58编码解码把给的数转换一下。_sEcond_Be5t_Time_1s_n0w}<br>结束</p>]]></content>
      
      
      <categories>
          
          <category> re wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>i春秋 竞赛训练营</title>
      <link href="/2019/11/12/i%E6%98%A5%E7%A7%8B-%E7%AB%9E%E8%B5%9B%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
      <url>/2019/11/12/i%E6%98%A5%E7%A7%8B-%E7%AB%9E%E8%B5%9B%E8%AE%AD%E7%BB%83%E8%90%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="CrackMe01"><a href="#CrackMe01" class="headerlink" title="CrackMe01"></a>CrackMe01</h1><p><img src="https://s2.ax1x.com/2019/11/12/M112uR.png" alt><br>打开字符串的话很难找到我们想要的函数的位置，所以不采取这个方法。<br>我们可以通过找api函数的办法来找到我们加密的位置。<br>这个时候需要打开输入函数，找到defwindowproc，这个api的功能是：</p><blockquote><p>调用重定向的窗口过程来为应用程序没有处理的任何窗口消息提供转换的处理。该函数确保每一个消息得到处理。</p></blockquote><p>这样我们双击来到这里<br><img src="https://s2.ax1x.com/2019/11/12/M132Rg.png" alt><br>右键查看外部引用<br><img src="https://s2.ax1x.com/2019/11/12/M18MY8.png" alt><br>一个一个查看，发现我们所需要的加密函数是在第一个交叉引用里面<br>进入函数<br><img src="https://s2.ax1x.com/2019/11/12/M1851e.png" alt><br>可以看到加密的函数有两个<br><code>do</code><br><code>{</code><br><code>*(&amp;chText + v12) ^ = v6;</code><br><code>v12 += 2;</code><br><code>}(v12 &lt; 44)</code></p><pre><code>if ( (v6 &amp; 0xF00) == 1024 &amp;&amp; (v6 &amp; 0xF0) == 176 &amp;&amp; (v6 &amp; 6) == 6 ){  showWindow((HWND)a1,5); UpdateWindow((HWND)a1);}</code></pre><p>根据这个加密函数，可写出解密函数:<br><code>for i in range(1,10000):</code><br>    <code>if(i &amp; 0xf00 == 1024):</code><br>        <code>if(i &amp; 0xf0 == 176):</code><br>            <code>if(i &amp; 6 == 6):</code><br>                <code>print(hex(i))</code><br><code>chText = [0x4F0, 0x4DA, 0x4D7, 0x4D1, 0x48C, 0x4FF, 0x4F5, 0x4FE, 0x4E3, 0x4F8, 0x4E7, 0x4FF, 0x4E3, 0x4E9, 0x4F0,0x4F3, 0x485, 0x480, 0x484, 0x4F2, 0x4F4, 0x4F3]</code><br><code>flag = &#39;&#39;</code><br><code>for i in range(22):</code><br>    <code>chText[i] ^= 0x4b6</code><br>    <code>flag += chr(chText[i])</code><br><code>print(flag)</code></p><p>总结：加密函数真的很简单了，但是这道题最让我困扰的是如何找到加密函数，今天学到了用api函数找到加密的位置，不给main函数是真的难受啊。网上的wp还有更麻烦的，有动态调试的，等等。看来要好好看一下win32编程了。顺便如果学会了动态调试的话，可以尝试用动态调试来解决问题，毕竟用动态调试跟踪系统函数的想法还是蛮不错的。</p>]]></content>
      
      
      <categories>
          
          <category> re wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>三叶草syc ctf </title>
      <link href="/2019/11/11/%E4%B8%89%E5%8F%B6%E8%8D%89syc-ctf/"/>
      <url>/2019/11/11/%E4%B8%89%E5%8F%B6%E8%8D%89syc-ctf/</url>
      
        <content type="html"><![CDATA[<h1 id="jiang’s-fan"><a href="#jiang’s-fan" class="headerlink" title="jiang’s fan"></a>jiang’s fan</h1><p>放入ida中，shift+f12查看字符串，就可以看到flag</p><h1 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h1><p>放入ida当中，查看主函数，看到base函数，函数中是对你输入的字符串进行base16加密，base16你可以理解为将字符串转换为16进制数字。main函数最后，将你输入的字符加密后和字符串比较，如果相同则输出正确。输入的字符为flag。可以用网上的base16进行解密，我当时做的时候用的爆破（主要是当时不知道base16。 解密代码先咕咕掉吧。等我会了在补上去</p><h1 id="冰菓"><a href="#冰菓" class="headerlink" title="冰菓"></a>冰菓</h1><p>放入detectit<br><img src="https://s2.ax1x.com/2019/11/17/MD8Jud.png" alt><br>.net文件，直接用dnspy来反编译<br>开始调试，设置中断在入口点，发现进入了bingo类里面，bingo类里面有个mainwindow，猜测是主函数可以进去看看。<br><img src="https://s2.ax1x.com/2019/11/17/MDGoJf.png" alt><br>里面有个encryptstr看上去像是加密类，先进去看看。<br><img src="https://s2.ax1x.com/2019/11/17/MDYB8K.png" alt><br>下面给了两个数组，然后进行了异或和相加的操作，直接写解密代码就可以了。<br>    code = [119,77,103,79,21,115,133,97,115,87,22,115,103,89,88,93,22,89,119,81]</p><pre><code>str = &#39;&#39;for i in range(len(code)):    str += chr((encode[i] - 13) ^ 0x39print(str)</code></pre><h1 id="dll-reverse"><a href="#dll-reverse" class="headerlink" title="dll reverse"></a>dll reverse</h1><p>dll文件不想多讲，百度都有。对于这道题来说直接把dll文件放进去分析就可以了。<br>很容易找到加密函数<br><img src="https://s2.ax1x.com/2019/11/17/MDNekn.png" alt><br>大概看一下，应该是base64再加上了一个异或的操作，结果也给了，直接逆向代码就可以得出要输入的代码了。还有一点要说的是base64中的对照表有一部分换了<br>下面是解密代码<br>    import base64</p><pre><code>list = bytes([69, 106, 67, 52, 86, 59, 79, 103, 71, 67, 25, 35, 67,117, 108, 103, 59, 101, 84, 70, 66, 55, 1, 80, 85, 96, 73, 36, 24, 74, 39, 31, 9, 29, 74, 0])list_1 = bytes([34, 89, 50, 94, 56, 11, 66, 86, 38, 112, 77, 69, 19, 34, 45, 29, 91, 55, 112, 3, 18, 96, 124, 54, 7, 83, 3, 83, 79,120, 86, 38, 0, 0, 0, 0])list_2 = []flag = &#39;&#39;for i in range(32):    if (i % 2 == 0):        list_2.append((list_1[i] - 3) ^ list[i])    else:        list_2.append((list_1[i] ^ list[i]))for i in range(len(list_2)):    flag += chr(list_2[i])table1 = &quot;ABCDEFGHIJKLMNOPQSVXZRWYTUeadbcfghijklmnopqrstuvwxyz0123456789+/&quot;table2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;print(base64.b64decode(flag.translate(flag.maketrans(table1,table2))))</code></pre><h1 id="EASY-VB"><a href="#EASY-VB" class="headerlink" title="EASY VB"></a>EASY VB</h1><p>当知道这是一个vb后，我尝试用vb decompiler pro来解决这道题，但发现这道题放进去后还是汇编函数，没办法反汇编。只能继续用ida pro进去读汇编。<br>shift + f12查找字符串，进去查找看看能有什么收获。<br><img src="https://s2.ax1x.com/2019/11/18/Ms7Y5Q.png" alt><br>这四句看起来比较关键，尤其是前面两句应该和flag有关，我们围绕这两句展开调查。<br><img src="https://s2.ax1x.com/2019/11/18/MsHwJH.png" alt><br>rtcMidCharVar，这是VB中⽤于截取字符串中字符的函数,⽽在下⼀个字符串赋值函数前,出现了jmp回到了rtcMidCharVar函数的上⽅,可知这是⼀个循环取字符的过程。<br><img src="https://s2.ax1x.com/2019/11/18/MsH2TS.png" alt><br>同理，在上方也可以发现有个rtcMidCharVar的函数和jmp的过程，猜测应该是对你输入的进行一一取值。<br><img src="https://s2.ax1x.com/2019/11/18/Msqu8J.png" alt><br>有一个将字符串转为ascii的函数，然后将eax和edx进行异或操作。得到的结果再和bKPObQ@goYBGRXjtVKVSn^@kFQh[V_]O进行比较。<br><img src="https://s2.ax1x.com/2019/11/18/MsqoZV.png" alt><br>这样就可以写出解密代码：<br>    import numpy as np</p><pre><code>a = &#39;bKPObQ@goYBGRXjtVKVSn^@kFQh[V_]O&#39;b = &#39;12345a789012345678g012345a789012&#39;a1 = np.fromstring(a,dtype=np.uint8)b1 = np.fromstring(b,dtype=np.uint8)flag = &#39;&#39;for i in xrange(len(a1)):    flag += chr(a1[i] ^ b1[i])print(flag)</code></pre><h1 id="re-py"><a href="#re-py" class="headerlink" title="re_py"></a>re_py</h1><pre><code>re_py源代码：print &quot;This is a maze.&quot;print &quot;Python is so easy.&quot;print &#39;Plz Input The Shortest Way:&#39;maze=&quot;###########S#@@@@@@##@#@####@##@#@@@@#@##@####@#@##@@@@@@#@#########@##E######@##@@@@@@@@###########&quot;way = raw_input()len = len(way)p=11for i in way:    if i==&quot;&amp;&quot;:        p-=10    if i==&quot;$&quot;:        p+=10    if i==&quot;6&quot;:        p-=1    if i==&quot;3&quot;:        p+=1    if maze[p]==&quot;#&quot;:        print &quot;Your way is wrong&quot;        exit(0)        break    if maze[p]==&quot;@&quot;:        continue    if maze[p]==&quot;E&quot;:    print &quot;You do it,your flag is Syc\{+Your Input+\}.&quot;    exit(0)print &quot;May be something wrong.&quot;</code></pre><p>从这里看来是一道迷宫题，十个字符为一行，&amp;是向上，$是向下，6是向左，3是向右<br>‘# # # # # # # # # #<br>‘# S # @ @ @ @ @ @ #<br>’# @ # @ # # # # @ #<br>‘# @ # @ @ @ @ # @ #<br>’# @ # # # # @ # @ #<br>‘# @ @ @ @ @ @ # @ #<br>’# # # # # # # # @ #<br>‘# E # # # # # # @ #<br>’# @ @ @ @ @ @ @ @ #<br>‘# # # # # # # # # #<br>根据图写出flag即可</p><h1 id="python1"><a href="#python1" class="headerlink" title="python1"></a>python1</h1><p>把文件放到python在线反编译当中，直接可以看到源代码</p><pre><code>源代码import structimport timedef b(a):    return a &amp; 0xFFFFFFFFFFFFFFFFdef c(str):    return struct.unpack(&#39;&lt;Q&#39;, str)[0]def d(a):    for i in range(64):        a = a * 2        if a &gt; 0xFFFFFFFFFFFFFFFF:            a = b(a)            a = b(a ^ 0xB0004B7679FA26B3)            continue    return aif __name__ == &#39;__main__&#39;:    cmp_data = [        0x6E8DD76D3B876F95,        0xE206DA09DAF4BED6,        0x77559D346E134BF1,        0x61CE39CAC5EAF891,        0x656C3C155520E36F]    input = input(&#39;plz input your flag:&#39;)    if len(input) % 8 != 0:        for i in range(8 - len(input) % 8):            input += &#39;\x00&#39;            arr = []    for i in range(len(input) // 8):        value = d(c(input[i * 8:i * 8 + 8]))        arr.append(value)    for i in range(5):        if arr[i] != cmp_data[i]:            print(&#39;fail&#39;)            time.sleep(5)            exit()            continue    print (&#39;success&#39;)    time.sleep(5)    exit()</code></pre><p>做题前⾸先熟悉python的使⽤，如struct.pack和struct.unpack，python和pyc⽂件反编译⽅⾯不多<br>提，Life is short, you need python。<br>题⽬的难点主要在于对d函数的逆向，会有64次乘⼆，每次乘2后还会进⾏判断，如果⼤于<br>0xffffffffffffffff，会&amp;0xffffffffffffffff再^ 0xB0004B7679FA26B3。<br>我们在些逆向脚本时候同样要进⾏64次的除以⼆，但是有个问题就是如何处理&amp;0xffffffffffffffff再^<br>0xB0004B7679FA26B3呢？<br>其实能看出来的话这道题就很简单了，⼊⼿点就是奇偶。<br>每次乘⼆后这⼀次循环得到的是偶数，每次&amp;0xffffffffffffffff再^ 0xB0004B7679FA26B3这⼀次循环得<br>到的都是奇数。我们写脚本进⾏64次循环除以⼆时候，先进⾏判断，如果是偶数就直接除以⼆，如果是<br>奇数就先^ 0xB0004B7679FA26B3，再+0xffffffffffffffff+1，再除以⼆即可。</p><pre><code>脚本：import structdef decode(a):    for i in range(64):        if(a%2 == 0):            a /= 2        else:            a ^=  0xB0004B7679FA26B3            a = a + 0xffffffffffffffff + 1            a /= 2    return aif __name__ == &#39;__main__&#39;:    cmp_data = [        0x6E8DD76D3B876F95,        0xE206DA09DAF4BED6,        0x77559D346E134BF1,        0x61CE39CAC5EAF891,        0x656C3C155520E36F]    flag = &#39;&#39;    for i in range(5):        flag += struct.pack(&quot;&gt;Q&quot;,decode(cmp_data[i]))[::-1].strip()        print(flag)</code></pre>]]></content>
      
      
      <categories>
          
          <category> re wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019 hectf re wp</title>
      <link href="/2019/11/06/2019-hectf-re-wp/"/>
      <url>/2019/11/06/2019-hectf-re-wp/</url>
      
        <content type="html"><![CDATA[<p>官方wp<br><a href="https://www.yuque.com/docs/share/e6c5d1fd-8d27-456a-88ab-823226503f56#helloRE" target="_blank" rel="noopener">https://www.yuque.com/docs/share/e6c5d1fd-8d27-456a-88ab-823226503f56#helloRE</a></p><h1 id="qiandao"><a href="#qiandao" class="headerlink" title="qiandao"></a>qiandao</h1><p>放在od中<br><img src="https://s2.ax1x.com/2019/11/06/MiV3QO.png" alt></p><h1 id="helloRe"><a href="#helloRe" class="headerlink" title="helloRe"></a>helloRe</h1><p>放在ida中，反编译<br><img src="https://s2.ax1x.com/2019/11/06/MiVMJx.png" alt><br>main函数：输入字符串，长度不能超过25，通过一个if语句即可获得success<br>查看sub_401080<br><img src="https://s2.ax1x.com/2019/11/06/MiV1SK.png" alt><br>sub_401080是对输入a1进行了处理<br>sub_401080的返回值是一个判断，函数sub_401000如果不等于0，则返回True<br>并且调用sub_401000时，传入经过处理的输入a1<br>进入sub_401000<br><img src="https://s2.ax1x.com/2019/11/06/MiVKF1.png" alt><br>if成立的条件是v3和输入相同，strcpy函数将aAy9ZZx9xoc9zI9复制给v3<br>阅读汇编可知<br><img src="https://s2.ax1x.com/2019/11/06/MiVQW6.png" alt><br>是经过sub_401080处理后的等于这一串字符串</p><p>明白后写出脚本：</p><pre><code>if __name__ == &quot;__main__&quot;:`f_flag = &#39;aY9)Z(?|ZX9xOC9z_i9eOYCw&#39;``flag = [0]*25``f_ord = [0]*25``for i in range(len(f_flag)):`   ` f_ord[i] = ord(f_flag[i])``for i in range(len(f_flag)):`    `if(f_ord[i]&gt;=40 and f_ord[i] &lt; 48):`        `flag[i] = f_ord[i] + 80`    `else:`        `if(f_ord[i]&gt;=62 and f_ord[i]&lt;=73):`            `flag[i] = f_ord[i] + 3`        `else:`            `if(f_ord[i]&gt;=79 and f_ord[i]&lt;92):`                `flag[i] = f_ord[i] -2`            `else:`                 `if(f_ord[i]&gt;=93 and f_ord[i]&lt;=107):`                    `flag[i] = f_ord[i] + 4`                `else:`                    `if(f_ord[i]&gt;=115 and f_ord[i]&lt;=125):`                        `flag[i] = f_ord[i] - 3`                    `else:`                        `if (f_ord[i] &lt; 38 and f_ord[i]&gt;29):`                            `flag[i] = f_ord[i] +1`                        `else:`                            `flag[i] = f_ord[i]``for i in range(len(flag)):`    `flag[i] = chr(flag[i])``flag1 = &#39;&#39;``for i in range(len(flag)):`    `flag1 += flag[i]``print(flag1)`  </code></pre><p>最后出来是eW91X0ByZV9uMF9wcm9iMWFt<br>最后进行base64解码<br>flag: flag{you_@re_n0_prob1am}</p>]]></content>
      
      
      <categories>
          
          <category> re wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>buuctf re wp</title>
      <link href="/2019/10/28/buuctf-re-wp/"/>
      <url>/2019/10/28/buuctf-re-wp/</url>
      
        <content type="html"><![CDATA[<h2 id="youngter-drive"><a href="#youngter-drive" class="headerlink" title="youngter-drive"></a>youngter-drive</h2><p><a href="https://hx1997.github.io/2018/07/22/anheng-july-re-youngter-drive/" target="_blank" rel="noopener">https://hx1997.github.io/2018/07/22/anheng-july-re-youngter-drive/</a></p><h2 id="crackRTF"><a href="#crackRTF" class="headerlink" title="crackRTF"></a>crackRTF</h2><p><a href="https://www.52pojie.cn/thread-994588-1-1.html" target="_blank" rel="noopener" title="wp">https://www.52pojie.cn/thread-994588-1-1.html</a><br>补充一些知识点：<br>有个PDB文件的类型</p><blockquote><p>PDB（Program Database File，程序数据库文件）文件物理结构在我们目前使用的掌上电脑中，Palm操作系统由于其功能强大、应用软件多等特点，占有很大的比例。PDB文件是Palm OS操作系统上数据文件类型。一般我们在使用Palm系统的电子书时都会遇到这种文件，一般用于电子书或手机电子书 pdb是Palm DataBase的缩写，Palm OS所用文件的扩展名为“.pdb”。还表示碳氧同位素标准样品以及可编程延迟模块，是DSP中的一种模块，可以用来计数和延时。<br>可以使用PalmReader打开。如果想把PDB文件转换成TXT文件查看，可以使用WavePDB转。<br><a href="https://baike.baidu.com/item/pdb/5357352" target="_blank" rel="noopener" title="具体内容">https://baike.baidu.com/item/pdb/5357352</a></p></blockquote><h2 id="GXYCTF2019-simple-CPP"><a href="#GXYCTF2019-simple-CPP" class="headerlink" title="[GXYCTF2019]simple CPP"></a>[GXYCTF2019]simple CPP</h2><p>先查看文件类型</p><p><img src="https://s2.ax1x.com/2020/01/18/1pnoBd.png" alt></p><p>用PEid看看是否有什么加密算法</p><p><img src="https://s2.ax1x.com/2020/01/18/1pnInH.png" alt></p><p>看来是没有</p><p>直接拖进ida64查看内容吧</p><p>有很多的函数，并且没有看到main函数，那就只能从字符串找找有什么突破口</p><p><img src="https://s2.ax1x.com/2020/01/18/1pnHAI.png" alt></p><p>看到congratulations了，看来这部分可能与flag有关系了，进去看看。</p><p><img src="https://s2.ax1x.com/2020/01/18/1pnTHA.png" alt></p><p>看到这个函数后，光读后面的部分就可以知道判断条件是什么，如下</p><pre><code>// v20 = 1176889593874// v20 = v15[2]&amp;~v15[0]// v24 = 4483974544037412639// v24=(v15[2]&amp;~v15[0])|(v15[1]&amp;v15[0])|(v15[2]&amp;~v15[1])|(v15[0]&amp;~v15[1])// v27=577031497978884115// v27=((v15[2]&amp;~v15[1])&amp;v15[0])|(v15[2]&amp;((v15[0]&amp;v15[1])|(v15[1]&amp;~v15[0])|~(v15[1]|v15[0])))// (v24 ^ v15[3]) == 4483974543195470111// v15[2]&amp;~v15[0]|v15[0]&amp;v15[1]|v15[1]&amp;v15[2] = ~v15[0]&amp;v15[2]|864693332579200012</code></pre><p>自己算的话不太可能，这时候可以借助z3求解器来解决计算问题代码如下：</p><pre><code>from z3 import *a,b,c,d=BitVecs(&#39;a b c d&#39;,64)s=Solver()s.add(~a&amp;c==1176889593874)s.add((c&amp;~a)|(b&amp;a)|(c&amp;~b)|(a&amp;~b)==4483974544037412639)s.add(((c&amp;~b)&amp;a)|(c&amp;((a&amp;b)|(b&amp;~a)|~(b|a)))==577031497978884115)s.add(((c&amp;~a)|(b&amp;a)|(c&amp;~b)|(a&amp;~b))^d==4483974543195470111)#print s.model()print s.check()print s.model()</code></pre><p>算出来的答案如下：</p><pre><code>sat[w = 842073600, y = 4483973367147818765, x = 4483973367147818765, z = 577031497978884115]</code></pre><p>感觉Y有点问题，不过先不管了。</p><p>把这几个数字转成十六进制再拼起来，后面会用到。</p><p>Y的部分直接都改成0x0</p><p><img src="https://s2.ax1x.com/2020/01/18/1pnX38.png" alt></p><p>上图的最下面的循环是很重要的一部分，是判断用来你输入是否是答案，这个v3就是刚才的v15，v7是上面的Dst，但是你没办法判断Dst的值，这时候看交叉引用来判断是哪个函数为它赋值的。如下图：</p><p><img src="https://s2.ax1x.com/2020/01/18/1pnvjg.png" alt></p><p>进去查看该函数</p><p><img src="https://s2.ax1x.com/2020/01/18/1pnzuQ.png" alt></p><p>读几个关键部分其实就能够知道Dst被赋值为”i_will_check_is_debug_or_not”</p><p>知道这些就够了，把我之前说的那个循环写个脚本就可以跑出来了。</p><p>脚本如下：</p><pre><code>a=&quot;i_will_check_is_debug_or_not&quot;b = [0x3e,0x3a,0x46,0x05,0x33,0x28,0x6f,0x0d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x08,0x2,0x07,0x17,0x15,0x3e,0x30,0x13,0x32,0x31,0x06,0x00,0x00]c=&#39;&#39;for i in range(0,27):        c += chr(ord(a[i%27])^b[i])print c</code></pre><p>y刚才说有问题，后来看官方wp应该是给hint补充了，这样子flag就出来了</p><blockquote><p>flag{We1l_D0ne!P0or_algebra_am_i}</p></blockquote><h2 id="findkey"><a href="#findkey" class="headerlink" title="findkey"></a>findkey</h2><p>放入detect it 检查发现是32位程序，而且是个PDB文件。</p><blockquote><p>PDB（Program Database File，程序数据库文件）文件物理结构在我们目前使用的掌上电脑中，Palm操作系统由于其功能强大、应用软件多等特点，占有很大的比例。PDB文件是Palm OS操作系统上数据<a href="https://baike.baidu.com/item/文件类型" target="_blank" rel="noopener">文件类型</a>。一般我们在使用Palm系统的电子书时都会遇到这种文件，一般用于电子书或手机电子书 pdb是Palm DataBase的缩写，Palm OS所用文件的扩展名为“.pdb”。</p></blockquote><p>但这里并不是重点。</p><p>再把它放到PEid中看一下有没有什么加密函数，</p><p><img src="https://s2.ax1x.com/2020/01/22/1AAby8.png" alt></p><p>点开细看可以看到是md5加密，md5的题目有需要爆破的可能性，再放到ida里看。</p><p>进入ida可以看到函数窗口里有winmain，进入看函数伪代码，应该是程序主界面的参数调整等，这部分不是很重要，接着往下看，看完所有函数的伪代码，只发现有一部分像加密的部分，如下图：</p><p><img src="https://s2.ax1x.com/2020/01/22/1AVeHg.png" alt></p><p>尝试跳转外部引用发现会跳转到一块汇编语言，左边是红色的部分可以猜测可能是花指令扰乱了正常汇编，先把左边的红色部分的地址用P键创建函数，然后发现有三个地方无法生成伪代码，先不管那些那些部分，先把生成的正常的部分看一下，有没有重要的部分。在寻找的过程中找到这个函数，</p><p><img src="https://s2.ax1x.com/2020/01/22/1AZ9qU.png" alt></p><p>v14和v18是重要的变量，进入sub_401005这个函数，</p><p><img src="https://s2.ax1x.com/2020/01/22/1AVeHg.png" alt></p><p>函数的算法加密过程并不难理解，两个参数都是已知的，就是v14和v18，可以写出脚本看一下，</p><pre><code class="python">key1=[]key=&#39;&#39;key2=&#39;0kk`d1a`55k222k2a776jbfgd`06cjjb&#39;for i in range(len(key2)):    key1.append(chr(ord(key2[i])^83))    key+=chr(ord(key2[i])^83)print(key)</code></pre><p>结果是 c8837b23ff8aaa8a2dde915473ce0991（也就是v18）</p><p>之后会经过一个strcmpi的函数进行比较</p><p>相等的话说明string1也是这个值，string1经过了一次md5的加密，这时候打开百度，查找md5解密可以破解出来string1的值应该为‘123321’</p><p>然后后面还有一个sub_401005，这次重点是v22和v13，v22是刚开始的string1也就是’123321’，v13就是那个byte_423030，然后根据这些可以写出脚本。</p><pre><code class="python">key1=&#39;123321&#39;key2=[87,94,82,84,73,95,1,109,105,70,2,110,95,2,108,87,91,84,76]key=&#39;&#39;for i in range(len(key2)):    key += chr(key2[i]^ord(key1[i%len(key1)]))print(key)</code></pre><p>结果是flag{n0_Zu0_n0_die}</p><p>这就是本次的答案</p><h2 id="SUCTF2019-SignIn"><a href="#SUCTF2019-SignIn" class="headerlink" title="[SUCTF2019]SignIn"></a>[SUCTF2019]SignIn</h2><p>本道题是一道RSA的题目有关RSA的算法可以上网查阅。</p><p>放到detectit查看是64位linux的文件，放到peid中查看是否有算法，看到有大数后可以猜测是RSA的算法。</p><p>进入ida查看程序</p><p><img src="https://s2.ax1x.com/2020/01/22/1EPzXF.png" alt></p><p>那个sub_96A不是重要的步骤，很容易懂，所以就不做分析了。</p><p>重要的是gmpz_init_set_str和gmpz_pown这两个函数，前者是用来初始化变量，后一个是将M的E次方模N放入M中。这两个函数是开源的数据库中的函数</p><blockquote><p>GMP，是GNU MP Bignum库的缩写，意思是开源数学运算库。GMP是GNU MP Bignum库，是一个开源的数学运算库，它可以用于任意精度的数学运算，包括有符号整数，有理数和浮点数。</p></blockquote><p>看来可以用来算大数运算。</p><p>前面分析了两个重要的函数的作用，再加上65537这些数字就已经可以确定是RSA了，直接按照破解rsa的流程就可以了。</p><p>首先要把大数N分解了，用yafu就可以了如下图：</p><p><img src="https://s2.ax1x.com/2020/01/22/1EFxZ4.png" alt></p><p>这样P和Q就知道了，还需要求欧拉函数，私钥，其实已经显而易见了，写个脚本就能出来了。</p><pre><code class="python">import gmpy2p = 366669102002966856876605669837014229419q = 282164587459512124844245113950593348271N = 103461035900816914121390101299049044413950405173712170434161686539878160984549c = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35e = 65537d = gmpy2.invert(e,(p-1)*(q-1))m = gmpy2.powmod(c,d,p*q)print hex(m)[2:].decode(&#39;hex&#39;)</code></pre><p>（说一下gmpy2的安装好麻烦233333~。）</p><h2 id="2019红帽杯-xx"><a href="#2019红帽杯-xx" class="headerlink" title="[2019红帽杯]xx"></a>[2019红帽杯]xx</h2><p>这题目花了我好长时间复现（因为真的是做不出来），不愧是最菜选手(哭)</p><p>放到detectit查看是64位PE文件，去peid中查看算法，发现是这么描述的</p><blockquote><p>A single DWORD, used in multiple crypto algorithms (TEA/N, RC 5/6, SERPENT, ISAAC, etc).</p></blockquote><p>看来有可能是tea类的或是RC类的算法加密等等。</p><p>进入ida细看一下吧</p><p>发现又是一堆函数，这时候只能查看字符串了，发现you win这个地方有可能和flag有关系，进入查看伪代码。</p><p>很长。。。。。。。</p><p>一部分一部分看吧</p><p>第一部分</p><p><img src="https://s2.ax1x.com/2020/01/31/133qhT.png" alt></p><p>这一部分是用来取出输入的flag的前四个字母，这个应该是众所周知的‘flag’的这四个字母，然后与code这个变量进行比较，是否是这个变量中的字母或数字。</p><p>第二部分：</p><p><img src="https://s2.ax1x.com/2020/01/31/13GlZR.png" alt></p><p>这一部分是进行xxtea的加密，其中sub_140001ab0就是加密的过程，这里就不放出来了，里面写的很复杂，不是很容易懂，这里放一个链接，大概了解一下xxtea原理</p><blockquote><p><a href="https://odoiys.github.io/2020/01/29/xxtea学习/" target="_blank" rel="noopener">https://odoiys.github.io/2020/01/29/xxtea%E5%AD%A6%E4%B9%A0/</a></p></blockquote><p>继续往下看第三部分：</p><p><img src="https://s2.ax1x.com/2020/01/31/13G5oq.png" alt></p><p>主要进行了将xxtea加密后的数组进行打乱，然后进行异或操作，最后进行和给出的&amp;v31,&amp;v31+1,&amp;v32,v33进行比较，这里是小端序，所以需要把它倒过拼接起来，拼接后的结果为：</p><p>CEBC406B7C3A95C0EF9B202091F70235231802C8E75656FA</p><p>过程清楚后写脚本来得到flag吧</p><pre><code class="python">import xxteadata0 = &quot;CEBC406B7C3A95C0EF9B202091F70235231802C8E75656FA&quot;#为提取出来的v29,v29+1,v30,v31data = []for i in range(0,len(data0),2):    data.append(int(data0[i]+data0[i+1],16))#每两位为整体，将16进制转换为10进制print(data)for i in range(len(data)-1,-1,-1):    for j in range(i//3):        data[i] ^= data[j]        #进行的异或操作print(data)change=[2,0,3,1,6,4,7,5,10,8,11,9,14,12,15,13,18,16,19,17,22,20,23,21]data1=[0 for i in range(24)]#print(data1)for i in range(24):    data1[change[i]]=data[i]print(data1)#encrypt_data=&#39;bca5ce40f4b2b2e7a9129d12ae10c85b3dd7061ddc70f8dc&#39;.decode(&#39;hex&#39;)#print(encrypt_data)key = &quot;flag&quot;encrypt_data=&#39;&#39;for i in range(len(data1)):    encrypt_data+=str(hex(data1[i]))print(encrypt_data)#bca5ce40f4b2b2e7a9129d12ae10c85b3dd761ddc70f8dcencrypt_data=&#39;bca5ce40f4b2b2e7a9129d12ae10c85b3dd7061ddc70f8dc&#39;.decode(&#39;hex&#39;)print(encrypt_data)key=&#39;flag\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#39;decrypt_data = xxtea.decrypt(encrypt_data,key,padding=False)#decrypt_data = xxtea.decrypt(encrypt_data,key)print decrypt_data</code></pre><p>这样就可以得到flag了</p><p>那阵还看到脚本更强的，还有把xxtea直接写出来，还有动态调试读流程的，简直无敌。</p><p>flag{CXX_and_++tea}</p><h2 id="GWCTF-2019-re3"><a href="#GWCTF-2019-re3" class="headerlink" title="[GWCTF 2019]re3"></a>[GWCTF 2019]re3</h2><p>放入detectit中可以看到是elf64，再放到peid中查看有哪些加密，md5,aes,base64，感觉很复杂的样子，进入ida64里看一下。</p><p><img src="https://s2.ax1x.com/2020/01/31/18MDN8.png" alt></p><p>直接进入main函数，看到一个异或操作，这个操作是用来把函数内容变换，这样子就没办法静态直接看到，可以选择用ida远程调试linux来动态查看sub_402219的真正面貌，之前还有个sub_40207b那个函数并没有对输入进行改变暂时不用看。sub_402219如下：<br><img src="https://s2.ax1x.com/2020/01/31/18Qu8g.png" alt></p><p>v4就是aes的key，byte_6030a0就是aes的加密结果，然后可以写脚本来解密：</p><pre><code class="python">from Crypto.Cipher import AEScipher1 = [0xBC, 0x0A, 0xAD, 0xC0, 0x14, 0x7C, 0x5E, 0xCC, 0xE0, 0xB1, 0x40, 0xBC, 0x9C, 0x51, 0xD5, 0x2B, 0x46, 0xB2, 0xB9, 0x43, 0x4D, 0xE5, 0x32, 0x4B, 0xAD, 0x7F, 0xB4, 0xB3, 0x9C, 0xDB, 0x4B, 0x5B]key1 = [0xcb, 0x8d, 0x49, 0x35, 0x21, 0xb4, 0x7a, 0x4c, 0xc1, 0xae, 0x7e, 0x62, 0x22, 0x92, 0x66, 0xce]#cipher = bytes(cipher1)cipher=&#39;\xBC\x0A\xAD\xC0\x14\x7C\x5E\xCC\xE0\xB1\x40\xBC\x9C\x51\xD5\x2B\x46\xB2\xB9\x43\x4D\xE5\x32\x4B\xAD\x7F\xB4\xB3\x9C\xDB\x4B\x5B&#39;#key = bytes(key1)key=&#39;\xcb\x8d\x49\x35\x21\xb4\x7a\x4c\xc1\xae\x7e\x62\x22\x92\x66\xce&#39;print(key)aes = AES.new(key, mode=AES.MODE_ECB)flag = aes.decrypt(cipher)print(flag)</code></pre><p>flag{924a9ab2163d390410d0a1f670}</p><p>下次一定更一下aes的原理，以上只是简单写一下wp的流程。下次一定下次一定。</p><p>emm，下面是AES的介绍，可以大概学习一下</p><blockquote><p><a href="https://odoiys.github.io/2020/02/01/AES加密学习/" target="_blank" rel="noopener">https://odoiys.github.io/2020/02/01/AES%E5%8A%A0%E5%AF%86%E5%AD%A6%E4%B9%A0/</a></p></blockquote><h2 id="GUET-CTF2019-re"><a href="#GUET-CTF2019-re" class="headerlink" title="[GUET-CTF2019]re"></a>[GUET-CTF2019]re</h2><p>用detectit查看是个elf64并且有UPX壳，用UPX工具自动脱壳，用PEID查看没有加密算法。进入ida查看代码。</p><p>并没有发现main函数，只能查找字符串来寻找信息。发现input your flag，correct等，就进到这里查看伪代码。</p><p><img src="https://s2.ax1x.com/2020/02/01/1GAbsf.png" alt></p><p>查看if判断的那个函数，参数是&amp;v1</p><p><img src="https://s2.ax1x.com/2020/02/01/1GEiLT.png" alt></p><p>直接写脚本就可以求得</p><pre><code class="python">a=[0 for i in range(31)]a[0] = 166163712//1629056a[1] = 731332800//6771600a[2] = 357245568//3682944a[3] = 1074393000//10431000a[4] = 489211344//3977328a[5] = 518971936//5138336a[6] = 406741500//7532250a[7] = 294236496//5551632a[8] = 177305856//3409728a[9] = 650683500//13013670a[10] = 298351053//6088797a[11] = 386348487//7884663a[12] = 438258597//8944053a[13] = 249527520//5198490a[14] = 445362764//4544518a[15] = 981182160//10115280a[16] = 174988800//3645600a[17] = 493042704//9667504a[18] = 257493600//5364450a[19] = 767478780//13464540a[20] = 312840624//5488432a[21] = 1404511500//14479500a[22] = 316139670//6451830a[23] = 619005024//6252576a[24] = 372641472//7763364a[25] = 373693320//7327320a[26] = 498266640//8741520a[27] = 452465676//8871876a[28] = 208422720//4086720a[29] = 515592000//9374400a[30] = 719890500//5759124#a[31] = 357245568//3682944flag=&#39;&#39;for i in range(len(a)):    flag+=chr(a[i])print(flag)</code></pre><p>注意原函数中并没有a1[6]，所以我选择一个一个试出来发现1是答案。</p><p>flag{e165421110ba03099a1c039337}</p>]]></content>
      
      
      <categories>
          
          <category> re wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows下的异常处理</title>
      <link href="/2019/10/26/Windows%E4%B8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2019/10/26/Windows%E4%B8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>本章介绍两中技术，一是SEH(结构化异常处理),二是VEH(向量化异常处理)</p><h1 id="一，异常处理的基本概念"><a href="#一，异常处理的基本概念" class="headerlink" title="一，异常处理的基本概念"></a>一，异常处理的基本概念</h1><p>中断：是由外部硬件设备或异步事件产生的。<br>异常：是由内部事件产生的，又可分为故障，陷阱和终止。</p><h2 id="1-异常列表"><a href="#1-异常列表" class="headerlink" title="1)异常列表"></a>1)异常列表</h2><p>除了CPU能够捕获一个事件并引发一个硬件异常外，在代码中可以主动引发一个软件异常，这只需要调用RaiseException()函数，实例如下：<br>void RaiseException(DWORD dwExceptionCode,//标识所引发的异常的代码<br>                    DWORD dwExceptionFlags,//异常是否继续执行的标识<br>                    DWORD nNumberOfArguments,//附加信息<br>                    CONST DWORD *lpArguments);//附加信息</p><h2 id="2-异常处理的基本过程"><a href="#2-异常处理的基本过程" class="headerlink" title="2)异常处理的基本过程"></a>2)异常处理的基本过程</h2>]]></content>
      
      
      <categories>
          
          <category> 加密与解密学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PE文件</title>
      <link href="/2019/10/21/PE%E6%96%87%E4%BB%B6/"/>
      <url>/2019/10/21/PE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>PE文件的全称是便携式可执行文件，意为可移植的替换的文件，常见的EXE，DLL，OCX，SYS，COM都是PE文件，PE文件是Microsoft Windows操作系统上的程序文件（可能是间接被执行，如DLL）<br><img src="https://i.imgur.com/RfcvH1I.jpg" alt></p><blockquote><p>基地址定义：当PE文件通过Windows加载器被装入内存后，内存中的版本被称作模块（Module）。映射文件的起始地址被称作模块句柄（hMoudule），可以通过模块句柄访问其他的数据结构。这个初始内存弟子就是基地址。<br>内存中的模块代表着进程从这个可执行文件中所需要的代码，数据，资源，输入表，输出表以及其他有用的数据结构所使用的内存都放在一个连续的内存块中，编程人员只要知道装载程序文件映像到内存的基地址即可。在32位系统中可以直接调用GetModuleHandle以取得指向DLL的指针，通过指针访问DLL module的内容，例如：<br>HMODULE GetmoduleHandle（LPCTSRT lpModuleName）；<br>当调用该函数时，传递一个可执行文件或者DLL文件名字字符串。如果系统找到该文件，则返回该可执行文件的或者DLL文件映像加载到的基地址。也可以调用GetModuleHandle,传递NULL参数，则返回调用的可执行文件的基地址。<br>相对虚拟地址:在可执行文件中，有相当多的地方需要指定内存的地址。例如：引用全局变量时，需要指定它的地址。PE文件尽管有一个首选的载入地址（基地址）,但是他们可以载入到进程空间的任意地方，所以不能依赖与PE的载入点。由于这个原因，必须有一个方法来指定一个地址而不是依赖于PE载入点。<br>为了在PE文件中避免有确定的内存地址，出现了相对虚拟地址(Relative Virtual Addres,简称RVA)的概念。RVA只是内存中的一个简单的相对于PE文件装入地址的偏移地址，它是一个“相对”地址，或者称位“偏移量”地址。例如：假设一个EXE文件从地址40000h处载入，并且它的代码区块开始于4010000h，代码区的RVA将是：<br>目标地址401000h ——转入地址400000h则RVA=1000h。<br>将RVA地址转换成真实地址，只需简单的翻转这个过程：将实际装入地址加上RVA即可得到实际的内存地址。顺便一提，在PE用语里，实际的内存地址被称作虚拟地址(Vritual Address，简称VA)，另外也可以把虚拟地址想象为加上首选装入地址的RVA。不要忘了前面提到的装入地址等同于模块句柄，它们之间的关系如下：<br>虚拟地址(VA)=基地址（ImageBase）+相对虚拟地址(RVA)</p></blockquote><h2 id="1）MS-DOS头部"><a href="#1）MS-DOS头部" class="headerlink" title="1）MS-DOS头部"></a>1）MS-DOS头部</h2><p>每个PE文件是以一个DOS程序开始的，有了它，一旦程序在DOS下执行，DOS就能辨别出这是个有效的执行体，然后运行紧随MZ header（后面会介绍）之后的DOS stub(DOS块)。DOS stub实际上是一个有效的EXE，在不支持PE文件格式的操作系统中，它将简单显示一个错误提示，类似于字符串“This Program cannot be run in MS-DOS”。用户通常对DOS stub 不感兴趣，因为大多数情况下他们由汇编器自动生成。平常把DOS stub和DOS MZ头部合称为DOS文件头。</p><p>PE文件的第一个字节起始于一个传统的MS-DOS头部，被称作IMAGE_DOS_HEADER。其IMAGE_DOS_HEADER的结构如下（左边的数字是到文件头的偏移量）：</p><pre><code>        IMAGE_DOS_HEADER STRUCT </code></pre><p>​<br>    { </p><pre><code>+0h WORD e_magic   // Magic DOS signature MZ(4Dh 5Ah) DOS可执行文件标记 +2h   WORD  e_cblp  // Bytes on last page of file+4h WORD  e_cp   // Pages in file +6h WORD  e_crlc   // Relocations +8h WORD  e_cparhdr   // Size of header in paragraphs +0ah WORD  e_minalloc  // Minimun extra paragraphs needs +0ch WORD  e_maxalloc  // Maximun extra paragraphs needs +0eh WORD  e_ss// intial(relative)SS value  DOS代码的初始化堆栈SS +10h WORD  e_sp// intial SP value DOS代码的初始化堆栈指针SP +12h WORD  e_csum// Checksum +14h WORD  e_ip//intial IP value DOS代码的初始化指令入口[指针IP] +16h WORD  e_cs// intial(relative)CS valueDOS代码的初始堆栈入口 +18h WORD  e_lfarlc// File Address of relocation table +1ah WORD  e_ovno//Overlay number +1ch WORD  e_res[4]// Reserved words +24h WORD  e_oemid//OEM identifier(for e_oeminfo) +26h WORD  e_oeminfo   //OEM information;e_oemid specific  +29h WORD  e_res2[10]   //Reserved words +3ch DWORD   e_lfanew // Offset to start of PE header 指向PE文件头 } IMAGE_DOS_HEADER ENDS</code></pre><p>这个结构中有两字段很重要，一个是e_magic,一个是e_lfanew。e_magic（一个字大小）字段需要被设置为5A4Dh这个也是PE程序载入的重要标志，这个值非常有意思，他们对应的字符分别位Z和M，是为了纪念MS-DOS的最初创建者Mark Zbikowski而专门设置的，由于在hex编辑器中显示是由低位到高位故显示为4D5Ah,刚好是创建者的名字缩写。另一个字段是e_lfanew。这个字段表示的是真正的PE文件头部相对偏移地址（RVA），它指出了真正PE头部文件偏移位置。它占用四个字节，位于文件开始偏移的3ch字节中。<br><img src="https://i.imgur.com/502a8sl.png" alt><br><img src="https://i.imgur.com/1gQk60T.png" alt></p><h2 id="2）PE文件头文件"><a href="#2）PE文件头文件" class="headerlink" title="2）PE文件头文件"></a>2）PE文件头文件</h2><p>紧跟着DOS头文件下面的就是peheader。PEheader是PE相关结构NT映像头（IMAGE_NT_HEADER）的简称，其中包含许多PE装载器用到的重要字段。执行体在支持PE文件结构的操作系统执行时，PE装载器将IMAGE_DOS_HEADER结构中的e_fanew字段找到PEheader的起始偏移量，加上基址得到PE文件头的指针：</p><p>PNTHeader=IMAGBase+dosHeader-&gt;e_lfanewr(其实就是去字段e_lfanew的值)</p><p>下面来讨论IMAGE_NT_HEADER的结构，它是由三个字段组成（左边的数字是PE文件头的偏移量）：<br>    STRUCT </p><pre><code>{ </code></pre><p>​<br>​<br>    +0h Signature  DWORD  //PE文件标志</p><pre><code>+4h FileHeader IMAGE_FILE_HEADER  //文件头初始偏移地址+18 optionalHeader IMAGE_OPTION_HEADER //另一个重要头部初始偏移地址</code></pre><p>​<br>​<br>    } IMAGE_NT_HEADER ENDS</p><p>Signature字段<br>这个字段是PE文件的标志字段，通常设置成00004550h，其ASCII码为PE00，这个字段是PE文件头的开始，前面的DOS_HEADER结构中的字段e_lfanew字段就是指向这里。<br><img src="https://i.imgur.com/K7MP7HM.png" alt><br>IMAGE_FILE_HEADER字段</p><p>这个字段也是包含几个字段结构，它包含了PE文件的一些基本信息，最重要的是其中一个域指出了IMAGE_OPTIONAL_HEADER的大小。<br>    typedef struct _IMAGE_FILE_HEADER {</p><pre><code>WORD Machine;//运行平台WORD NumberOfSections;//文件的区块数目DWORD TimeDateStamp;//文件创建的用时间戳标识的日期DWORD PointerToSymbolTable;//指向符号表（用于调试）DWORD NumberOfSymbols;//符号表中符号的个数WORD SizeOfOptionalHeader;//IMAGE_OPTIONAL_HEADER32结构大小WORD Characteristics;//文件属性} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</code></pre><p><img src="https://i.imgur.com/ao7iSVJ.png" alt></p><p>上图标出七个字段的位置及各自的值。</p><p>1）Machine字段，表示目标CPU 的类型。</p><p>几个常见的及其标识如下：</p><p>机器              标识     </p><p>Intel I386          14ch</p><p>MIPS R3000        162h</p><p>Alpha AXP          184h</p><p>Power PC           1F0h</p><p>MIPS R4000         184h</p><p>根据以上信息我们知道这个PE文件要运行在Intel I386机器上。</p><p>2）NumberOfSection，标识区块的数目，关于区块后面会详细讲。</p><p>3）TimeDateStamp</p><p>这个字段没啥好说的，指的就是PE文件创建的事件，这个时间是指从1970年1月1日到创建该文件的所有的秒数。</p><p>4）PointerToSymbolTable。这个字段用的比较少，略</p><p>5）NumberOfSymbol。这个字段也用得很少，略</p><p>6）SizeOfOptionalHeader：紧跟着IMAGE_FILE_HEADER后面的数据大小，这也是一个数据结构，它叫做IMAGE_OPTIONAL_HEADER,其大小依赖于是64位还是32位文件。32位文件值通常是00EOh，对于64位值通常为00F0h。</p><p>7）Characteristics：文件属性，普通EXE文件这个字段值为010fh，DLL文件这个字段一般是0210h。</p><h2 id="3）IMAGE-OPTIONAL-HEADER概述"><a href="#3）IMAGE-OPTIONAL-HEADER概述" class="headerlink" title="3）IMAGE_OPTIONAL_HEADER概述"></a>3）IMAGE_OPTIONAL_HEADER概述</h2><p>这个结构是IMAGE_FILE_HEADER结构的补充。这个结构异常复杂，但真正我们用得到的其实不多。看下面的代码：<br>    typedef struct _IMAGE_OPTIONAL_HEADER<br>    {<br>    //<br>    // Standard fields.<br>    //<br>    +18hWORDMagic; // 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）<br>    +1AhBYTE  MajorLinkerVersion; // 链接程序的主版本号<br>    +1BhBYTE  MinorLinkerVersion; // 链接程序的次版本号<br>    +1ChDWORD   SizeOfCode; // 所有含代码的节的总大小<br>    +20hDWORD   SizeOfInitializedData;// 所有含已初始化数据的节的总大小<br>    +24hDWORD   SizeOfUninitializedData; // 所有含未初始化数据的节的大小<br>    +28hDWORD   AddressOfEntryPoint;// 程序执行入口RVA<br>    +2ChDWORD   BaseOfCode;  // 代码的区块的起始RVA<br>    +30hDWORD   BaseOfData;  // 数据的区块的起始RVA<br>    //<br>    // NT additional fields.以下是属于NT结构增加的领域。<br>    //<br>    +34hDWORD   ImageBase;  // 程序的首选装载地址                                  !<br>    +38hDWORD   SectionAlignment;  // 内存中的区块的对齐大小                        !<br>    +3ChDWORD   FileAlignment;  // 文件中的区块的对齐大小                           !<br>    +40hWORDMajorOperatingSystemVersion;  // 要求操作系统最低版本号的主版本号<br>    +42hWORDMinorOperatingSystemVersion;  // 要求操作系统最低版本号的副版本号<br>    +44hWORDMajorImageVersion;   // 可运行于操作系统的主版本号<br>    +46hWORDMinorImageVersion;   // 可运行于操作系统的次版本号<br>    +48hWORDMajorSubsystemVersion;  // 要求最低子系统版本的主版本号<br>    +4AhWORDMinorSubsystemVersion;  // 要求最低子系统版本的次版本号<br>    +4ChDWORD   Win32VersionValue;   // 莫须有字段，不被病毒利用的话一般为0<br>    +50hDWORD   SizeOfImage;   // 映像装入内存后的总尺寸<br>    +54hDWORD   SizeOfHeaders;   // 所有头 + 区块表的尺寸大小<br>    +58hDWORD   CheckSum;   // 映像的校检和<br>    +5ChWORDSubsystem;   // 可执行文件期望的子系统<br>    +5EhWORDDllCharacteristics;   // DllMain()函数何时被调用，默认为 0<br>    +60hDWORD   SizeOfStackReserve;   // 初始化时的栈大小<br>    +64hDWORD   SizeOfStackCommit;   // 初始化时实际提交的栈大小<br>    +68hDWORD   SizeOfHeapReserve;// 初始化时保留的堆大小<br>    +6ChDWORD   SizeOfHeapCommit;// 初始化时实际提交的堆大小<br>    +70hDWORD   LoaderFlags;// 与调试有关，默认为 0<br>    +74hDWORD   NumberOfRvaAndSizes;  // 下边数据目录的项数，这个字段自Windows NT 发布以来// 一直是16<br>    +78hDWORD   DataDirctory[16];                                                !<br>       // 数据目录表<br>    } IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</p><p>最常用的是用后面叹号标注的<img src="https://i.imgur.com/bTSe4rn.png" alt></p><p>前面我们已经知道了PE文件头在40h的位置，则上面的偏移量推断IMAGE_OPTIONAL_HEADER字段的首个字段在40h+18h=58h的地方，我们还是用hexwrokshop打开那个PE文件。Ctrl+G打开转移窗口，输入58则找到了第一个字段位置，如下图：<br><img src="https://i.imgur.com/cg9zve8.png" alt><br>下面是DataDirctory[16]即数据目录表的各个成员：<br><img src="https://i.imgur.com/YNQ7DmF.png" alt><br>这张表的16个成员中第一个成员IMAGE_DIRECTORY_ENTRY_EXPORT（导出表）和第二个成员IMAGE_DIRECTORY_ENTRY_EXPORT（导入表）非常重要。<br>用Hexwrokshop打开文件，首先找到PE文件头位置，一般都是在载入起始位+3ch处，如下图所示。<br><img src="https://i.imgur.com/LplosQw.png" alt><br>找到了PE文件头的位置，接下来我们来找DataDirctory[16]各个成员位置。第一个成员输出表位于PE文件头+78h位置即100h+78h=178h处，如下图：<br><img src="https://i.imgur.com/JEYwswl.png" alt></p><p>由于每个结构都占8个字节，所以可以知道输出表的其实位置在4000h处，大小为45h</p><p>输入表的位置位100h+80h=180h处，如下图：<br><img src="https://i.imgur.com/NUAg0g4.png" alt><br>由上图可知输入表的起始位置在3000h处，大小为52h。</p><blockquote><p>查找输入表和输出表的方法还可以用peid或是lordpe</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 逆向工程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux指令记录</title>
      <link href="/2019/10/20/linux%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/10/20/linux%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="更换Unbuntu的源："><a href="#更换Unbuntu的源：" class="headerlink" title="更换Unbuntu的源："></a>更换Unbuntu的源：</h2><pre><code class="shell">sudo gedit /etc/apt/sources.list-----------------------------------------------------------------------------#阿里云的源：deb http://mirrors.aliyun.com/ubuntu/ xenial maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial maindeb http://mirrors.aliyun.com/ubuntu/ xenial-updates maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates maindeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security maindeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe-----------------------------------------------------------------------------sudo apt-get updatesudo apt-get upgrade</code></pre><h2 id="设置中文的方法："><a href="#设置中文的方法：" class="headerlink" title="设置中文的方法："></a>设置中文的方法：</h2><pre><code class="shell">sudo apt-get install  language-pack-zh-han*</code></pre><p>然后再在语言设置中修改语言即可</p><h2 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法:"></a>安装中文输入法:</h2><pre><code class="shell">sudo apt-get install fcitxsudo dpkg -i sogoupinyin_2.3.1.0112_amd64.deb</code></pre><p>再到语言设置中改一下就可以了</p><h2 id="加快PIP下载的办法："><a href="#加快PIP下载的办法：" class="headerlink" title="加快PIP下载的办法："></a>加快PIP下载的办法：</h2><pre><code class="bash">cd ~   先切换到home文件夹下;ls -a   查看是否有.pip的文件,没有的话创建mkdir .pip  创建.pip文件夹cd .pip    进入.pip文件夹touch pip.conf  创建pip.conf的文件在 pip.conf文件内添加以下内容, 可用vim也可以手动打开复制粘贴[global] 　　index-url = https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><h2 id="安装angr的方法："><a href="#安装angr的方法：" class="headerlink" title="安装angr的方法："></a>安装angr的方法：</h2><p>因为我直接用kali安装，所以不在乎python的问题，不想创造虚拟环境直接安装</p><pre><code class="bash">pip install angrpip install monkeyhex-------------------------------安装CFG可视化CFG可视化：angr-utils能够实现CFG（以及其他流图）的可视化-------------------------------git clone https://github.com/axt/bingraphvispip install -e ./bingraphvisgit clone https://github.com/axt/angr-utilspip install -e ./angr-utils</code></pre><h2 id="更换主题："><a href="#更换主题：" class="headerlink" title="更换主题："></a>更换主题：</h2><p>首先要安装下gnom-tweaks-tool:</p><pre><code class="shell">sudo add-apt-repository universesudo apt install gnome-tweak-tool</code></pre><p>解决没有安装gnome的方法：</p><blockquote><p><a href="https://blog.csdn.net/m0_37407587/article/details/87911749" target="_blank" rel="noopener">https://blog.csdn.net/m0_37407587/article/details/87911749</a></p></blockquote><p>最后就可以安装主题了</p><h2 id="编译汇编代码："><a href="#编译汇编代码：" class="headerlink" title="编译汇编代码："></a>编译汇编代码：</h2><pre><code class="shell">vim hello.asmnasm -f hello.asmld -m  elf_i386 -s -o hello hello.o</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DLL学习</title>
      <link href="/2019/10/17/DLL%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/10/17/DLL%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>库文件:DLL(Dynamic Link Library),是动态链接库文件，又称“应用程序拓展”，是软文件类型。在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。<br>DLL 的编制与具体的编程语言及编译器无关</p><ol><li>只要遵循约定的DLL接口规范和调用方式，用各种语言编写的DLL都可以相互调用。譬如Windows提供的系统DLL（其中包括了Windows的API），在任何开发环境中都能被调用，不在乎其是Visual Basic、Visual C++还是Delphi。</li><li>动态链接库随处可见<br>我们在Windows目录下的system32文件夹中会看到kernel32.dll、user32.dll和gdi32.dll，windows的大多数API都包含在这些DLL中。kernel32.dll中的函数主要处理内存管理和进程调度；user32.dll中的函数主要控制用户界面；gdi32.dll中的函数则负责图形方面的操作。<br>一般的程序员都用过类似MessageBox的函数，其实它就包含在user32.dll这个动态链接库中。由此可见DLL对我们来说其实并不陌生。<br>要使用加载时动态链接，请在编译和链接应用程序时提供头文件 (.h) 和导入库文件 (.lib)。当您这样做时，链接器将向系统提供加载 DLL 所需的信息，并在加载时解析导出的 DLL 函数的位置。 运行时动态链接在运行时动态链接中，应用程序调用 LoadLibrary 函数或 LoadLibraryEx 函数以在运行时加载 DLL。成功加载 DLL 后，可以使用 GetProcAddress 函数获得要调用的导出的 DLL 函数的地址。在使用运行时动态链接时，无需使用导入库文件。</li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
