<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2020hgame-re-wp</title>
      <link href="/2020/02/07/2020hgame-re-wp/"/>
      <url>/2020/02/07/2020hgame-re-wp/</url>
      
        <content type="html"><![CDATA[<h2 id="WEEK2"><a href="#WEEK2" class="headerlink" title="WEEK2:"></a>WEEK2:</h2><h3 id="unpack"><a href="#unpack" class="headerlink" title="unpack:"></a>unpack:</h3><p>这道题有两种思路都要学会，官方给的那种方法（第一种方法）更好一些，直接给这两个链接。</p><p>第一种方法：</p><blockquote><p><a href="https://www.52pojie.cn/thread-1048649-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1048649-1-1.html</a></p></blockquote><p>第二种方法：</p><blockquote><p><a href="https://blog.csdn.net/Palmer9/article/details/104119621" target="_blank" rel="noopener">https://blog.csdn.net/Palmer9/article/details/104119621</a></p></blockquote><p>flag脚本在第二种方法里有给</p>]]></content>
      
      
      <categories>
          
          <category> re wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -UPX -dump -re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jarvisoj-re-wp</title>
      <link href="/2020/02/05/jarvisoj-re-wp/"/>
      <url>/2020/02/05/jarvisoj-re-wp/</url>
      
        <content type="html"><![CDATA[<h2 id="软件密码破解-1"><a href="#软件密码破解-1" class="headerlink" title="软件密码破解-1"></a>软件密码破解-1</h2><p>放到detectit中查看文件的类型，发现是MFC微软的win32编程，建议od动态调试，放到peid中查询，没有加密函数。</p><p>放到ida中只能看到有一堆的函数，winmain也没有足够的信息。字符串中也没有找到有关flag的字符。只能转战od动态调试。</p><p>在od中右键中文搜索引擎中的智能搜索有意外的发现。</p><p><img src="https://s2.ax1x.com/2020/02/05/1rfKvF.png" alt></p><p>发现了可能有关flag的地方，在这里下一个断点，然后向上寻找线索。</p><p><img src="https://s2.ax1x.com/2020/02/05/1rfXMF.png" alt></p><p>这时候需要运行然后顺着断点的地方向上找到输入的地方，在这里</p><p><img src="https://s2.ax1x.com/2020/02/05/1r5mCt.png" alt></p><p>解读下上面的汇编，输入的地址放入了ebx中，ptr ds:[ebx]可以调用你输入的字符串，然后把ebx赋给eax,重点是60到67的循环，用ptr ds:[ecx+eax]的字符串放到dl中（查看ptr ds:[eax+ecx]的方法是先把鼠标放到你要查的位置上然后右键数据窗口中跟随，选择内存地址便可以再左下角的内存窗口上查看），然后让dl与ptr ds:[eax]的字符串进行异或，eax刚才被ebx赋值了，也就是说ptr ds:[eax]就是你所输入的字符串，它与系统中的某组字符串进行了异或。再往下有几个cmp的比较，是用你输入的经过异或变换的字符串与所显示的字符串进行比较，这些所显示出来的数字因为是小端序排列的所以，要进行变换顺序才能进行正常比较（写脚本的时候注意）。</p><p>脚本如下：</p><pre><code class="python">flag=&#39;&#39;a=[0x28,0x57,0x64,0x6b,0x93,0x8f,0x65,0x51,0xe3,0x53,0xe4,0x4e,0x1a,0xff]b=[0x1b,0x1c,0x17,0x46,0xf4,0xfd,0x20,0x30,0xb7,0xc,0x8e,0x7e,0x78,0xde]for i in range(len(a)):    flag+=chr(a[i]^b[i])print(flag)</code></pre><p>flag是3Ks-grEaT_j0b!</p><h2 id="findkey"><a href="#findkey" class="headerlink" title="findkey"></a>findkey</h2><p>这是一个pyc文件是由python语言写成的，直接使用python在线反编译就可以看到源码，由于结构太简单了就不贴了，方法是脚本爆破，直接上脚本就好了：</p><pre><code class="python">lookup = [    196,    153,    149,    206,    17,    221,    10,    217,    167,    18,    36,    135,    103,    61,    111,    31,    92,    152,    21,    228,    105,    191,    173,    41,    2,    245,    23,    144,    1,    246,    89,    178,    182,    119,    38,    85,    48,    226,    165,    241,    166,    214,    71,    90,    151,    3,    109,    169,    150,    224,    69,    156,    158,    57,    181,    29,    200,    37,    51,    252,    227,    93,    65,    82,    66,    80,    170,    77,    49,    177,    81,    94,    202,    107,    25,    73,    148,    98,    129,    231,    212,    14,    84,    121,    174,    171,    64,    180,    233,    74,    140,    242,    75,    104,    253,    44,    39,    87,    86,    27,    68,    22,    55,    76,    35,    248,    96,    5,    56,    20,    161,    213,    238,    220,    72,    100,    247,    8,    63,    249,    145,    243,    155,    222,    122,    32,    43,    186,    0,    102,    216,    126,    15,    42,    115,    138,    240,    147,    229,    204,    117,    223,    141,    159,    131,    232,    124,    254,    60,    116,    46,    113,    79,    16,    128,    6,    251,    40,    205,    137,    199,    83,    54,    188,    19,    184,    201,    110,    255,    26,    91,    211,    132,    160,    168,    154,    185,    183,    244,    78,    33,    123,    28,    59,    12,    210,    218,    47,    163,    215,    209,    108,    235,    237,    118,    101,    24,    234,    106,    143,    88,    9,    136,    95,    30,    193,    176,    225,    198,    197,    194,    239,    134,    162,    192,    11,    70,    58,    187,    50,    67,    236,    230,    13,    99,    190,    208,    207,    7,    53,    219,    203,    62,    114,    127,    125,    164,    179,    175,    112,    172,    250,    133,    130,    52,    189,    97,    146,    34,    157,    120,    195,    45,    4,    142,    139]pwda = [    188,    155,    11,    58,    251,    208,    204,    202,    150,    120,    206,    237,    114,    92,    126,    6,    42]pwdb = [    53,    222,    230,    35,    67,    248,    226,    216,    17,    209,    32,    2,    181,    200,    171,    60,    108]flag=&#39;&#39;for i in range(0,17):    for x in range(0,255):        if (x + pwda[i] &amp; 255) == lookup[i+pwdb[i]]:            flag+=chr(x)flag=flag[::-1]print(flag)</code></pre>]]></content>
      
      
      <categories>
          
          <category> re wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AES加密学习</title>
      <link href="/2020/02/01/AES%E5%8A%A0%E5%AF%86%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/02/01/AES%E5%8A%A0%E5%AF%86%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="AES原理"><a href="#AES原理" class="headerlink" title="AES原理:"></a>AES原理:</h3><blockquote><p><a href="https://blog.csdn.net/gulang03/article/details/81175854" target="_blank" rel="noopener">https://blog.csdn.net/gulang03/article/details/81175854</a></p></blockquote><h3 id="AES的四种模式"><a href="#AES的四种模式" class="headerlink" title="AES的四种模式:"></a>AES的四种模式:</h3><blockquote><p><a href="https://www.cnblogs.com/liangxuehui/p/4651351.html" target="_blank" rel="noopener">https://www.cnblogs.com/liangxuehui/p/4651351.html</a></p></blockquote><h3 id="AES的算法代码"><a href="#AES的算法代码" class="headerlink" title="AES的算法代码:"></a>AES的算法代码:</h3><blockquote><p><a href="https://blog.csdn.net/shaosunrise/article/details/80219950" target="_blank" rel="noopener">https://blog.csdn.net/shaosunrise/article/details/80219950</a></p></blockquote><p>感觉这几篇说的都很详细，网上的关于AES的介绍都挺清晰，都可以用来学习。</p>]]></content>
      
      
      <categories>
          
          <category> crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxtea学习</title>
      <link href="/2020/01/29/xxtea%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/01/29/xxtea%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>大概介绍一下xxtea的原理，发现最近re的题目很喜欢出</p><p>原理图如下：</p><p><img src="https://s2.ax1x.com/2020/01/29/1Q2JET.png" alt></p><p>加密解密代码如下：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define DELTA 0x9e3779b9#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))void btea(uint32_t *v, int n, uint32_t const key[4]){    uint32_t y, z, sum;    unsigned p, rounds, e;    if (n &gt; 1)            /* Coding Part */    {        rounds = 6 + 52/n;        sum = 0;        z = v[n-1];        do        {            sum += DELTA;            e = (sum &gt;&gt; 2) &amp; 3;            for (p=0; p&lt;n-1; p++)            {                y = v[p+1];                z = v[p] += MX;            }            y = v[0];            z = v[n-1] += MX;        }        while (--rounds);    }    else if (n &lt; -1)      /* Decoding Part */    {        n = -n;        rounds = 6 + 52/n;        sum = rounds*DELTA;        y = v[0];        do        {            e = (sum &gt;&gt; 2) &amp; 3;            for (p=n-1; p&gt;0; p--)            {                z = v[p-1];                y = v[p] -= MX;            }            z = v[n-1];            y = v[0] -= MX;            sum -= DELTA;        }        while (--rounds);    }}int main(){    uint32_t v[2]= {1,2};    uint32_t const k[4]= {2,2,3,4};    int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密    // v为要加密的数据是两个32位无符号整数    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位    printf(&quot;加密前原始数据：%u %u\n&quot;,v[0],v[1]);    btea(v, n, k);    printf(&quot;加密后的数据：%u %u\n&quot;,v[0],v[1]);    btea(v, -n, k);    printf(&quot;解密后的数据：%u %u\n&quot;,v[0],v[1]);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RSA密码学习</title>
      <link href="/2020/01/16/RSA%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/01/16/RSA%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="center">步骤</th><th align="center">描述</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">找出两个质数</td><td align="center">P,Q</td><td align="center"></td></tr><tr><td align="center">计算公共模数</td><td align="center">N=P*Q</td><td align="center"></td></tr><tr><td align="center">欧拉函数</td><td align="center">φ(N)=(P-1)(Q-1)</td><td align="center"></td></tr><tr><td align="center">计算公钥E</td><td align="center">1&lt;E&lt;φ(N)</td><td align="center">E的取值必须是整数   E和φ(N)必须是互质数</td></tr><tr><td align="center">计算私钥D</td><td align="center">E*D%φ(N)=1</td><td align="center"></td></tr><tr><td align="center">加密</td><td align="center">C=M的E次方 mod N</td><td align="center">C：密文 M：明文</td></tr><tr><td align="center">解密</td><td align="center">M=C的D次方 mod N</td><td align="center">C：密文 M：明文</td></tr></tbody></table><p>公钥=(E,N)</p><p>私钥=(D,N)</p><p>解密</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="1，找出质数P-Q"><a href="#1，找出质数P-Q" class="headerlink" title="1，找出质数P,Q"></a>1，找出质数P,Q</h4><p>$$<br>P=3<br>$$</p><p>$$<br>Q=11<br>$$</p><h4 id="2，计算公共模数"><a href="#2，计算公共模数" class="headerlink" title="2，计算公共模数"></a>2，计算公共模数</h4><p>$$<br>N=P<em>Q=3</em>11=33<br>$$</p><h4 id="3，欧拉函数"><a href="#3，欧拉函数" class="headerlink" title="3，欧拉函数"></a>3，欧拉函数</h4><p>$$<br>φ(N) = (P-1)(Q-1) = 2 * 10 = 20<br>$$</p><h4 id="4，计算公钥E"><a href="#4，计算公钥E" class="headerlink" title="4，计算公钥E"></a>4，计算公钥E</h4><p>$$<br>1 &lt; E &lt; φ(N)<br>$$</p><p>$$<br>1 &lt;E &lt; 20<br>$$</p><blockquote><p>E 的取值范围 {3, 7, 9, 11, 13, 17, 19}<br>E的取值必须是整数, E 和 φ(N) 必须是互质数<br>为了测试，我们取最小的值 <strong>E =3</strong><br>3 和 φ(N) =20 互为质数，满足条件</p></blockquote><h4 id="5，计算私钥D"><a href="#5，计算私钥D" class="headerlink" title="5，计算私钥D"></a>5，计算私钥D</h4><p>$$<br>E * D mod φ(N) = 1<br>$$</p><p>$$<br>3 * D  mod 20 = 1<br>$$</p><h4 id="6，公钥加密"><a href="#6，公钥加密" class="headerlink" title="6，公钥加密"></a>6，公钥加密</h4><p><img src="https://s2.ax1x.com/2020/01/16/lj5Cee.png" alt="加密"></p><blockquote><p>M = 2 </p><p>E = 3 </p><p>N = 33</p></blockquote><blockquote><p>C = 8</p></blockquote><h4 id="7，私钥解密"><a href="#7，私钥解密" class="headerlink" title="7，私钥解密"></a>7，私钥解密</h4><p><img src="https://s2.ax1x.com/2020/01/16/lj5PdH.png" alt="解密"></p><blockquote><p>C = 8</p><p>D = 7</p><p>N = 33</p></blockquote><blockquote><p>M = 2</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>花指令学习</title>
      <link href="/2020/01/14/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/01/14/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在原来的汇编程序中加入一些干扰阅读的代码，这些代码可以看做是花指令。</p><p>这类题在ctf中很常见，但是要多加练习。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>总体上花指令分为两类，一类是可履行式花指令，另一类为不可履行式花指令（废物指令）。</p><p>对于可履行式花指令，望文生义就是能够正常运转的但又不改动原始程序逻辑性的一组无用指令。这类花指令有如下特色：</p><p>①能够正常运转；</p><p>②不改动任何寄存器的值；</p><p>③反汇编器能够正确反汇编该指令。</p><p>对于不可履行式花指令，是指被刺进到原始代码中但又不改动原始程序逻辑性的一组无用字节。这类花指令有如下特色：</p><p>①不行以正常运转；</p><p>②不改动任何寄存器的值；</p><p>③反汇编器或许会过错反汇编这些字节。</p><h3 id="花指令的经典模型"><a href="#花指令的经典模型" class="headerlink" title="花指令的经典模型"></a>花指令的经典模型</h3><h4 id="1-伪装-vc"><a href="#1-伪装-vc" class="headerlink" title="1.伪装 vc"></a>1.伪装 vc</h4><p><code>VC++程序的入口代码:</code></p><p><code>PUSH EBP</code></p><p><code>MOV EBP,ESP</code></p><p><code>PUSH -1</code></p><p><code>push 415448 -\___</code></p><p><code>PUSH 4021A8 // 在这段代码中类似这样的[操作数](https://baike.baidu.com/item/操作数)可以乱填</code></p><p><code>MOV EAX,DWORD PTR FS:[0]</code></p><p><code>PUSH EAX</code></p><p><code>MOV DWORD PTR FS:[0],ESP</code></p><p><code>ADD ESP,-6C</code></p><p><code>PUSH EBX</code></p><p><code>PUSH ESI</code></p><p><code>PUSH EDI</code></p><p><code>ADD BYTE PTR DS:[EAX],AL //这条指令可以不要!</code></p><p><code>jmp 跳转到程序原来的入口点</code></p><h4 id="2-跳转"><a href="#2-跳转" class="headerlink" title="2.跳转"></a>2.跳转</h4><p><code>somewhere:</code><br><code>nop //&quot;胡乱&quot;跳转的开始...</code><br><code>jmp 下一个jmp的地址 /在附近随意跳</code><br><code>jmp ... //...</code><br><code>jmp 原入口的地址 //跳到原始oep</code></p><hr><p><code>新入口: push ebp</code></p><p><code>mov ebp,esp</code></p><p><code>inc ecx</code></p><p><code>push edx</code></p><p><code>nop</code></p><p><code>pop edx</code></p><p><code>dec ecx</code></p><p><code>pop ebp</code></p><p><code>inc ecx</code></p><p><code>loop somewhere //跳转到上面那段代码地址去！</code></p><h4 id="3-伪装c"><a href="#3-伪装c" class="headerlink" title="3.伪装c"></a>3.伪装c</h4><p><code>融合</code></p><p><code>把A的代码换成B的</code></p><p><code>push ebp</code></p><p><code>mov ebp,esp</code></p><p><code>push -1</code></p><p><code>push 111111</code></p><p><code>push 222222</code></p><p><code>mov eax,fs:[0]</code></p><p><code>push eax</code></p><p><code>mov fs:[0],esp</code></p><p><code>pop eax</code></p><p><code>mov fs:[0],eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>mov ebp,eax</code></p><p><code>jmp 老入口</code></p><h4 id="4-c"><a href="#4-c" class="headerlink" title="4.c ++"></a>4.c ++</h4><p><code>push ebp</code></p><p><code>mov ebp,esp</code></p><p><code>push -1</code></p><p><code>push 111111</code></p><p><code>push 222222</code></p><p><code>mov eax,fs:[0]</code></p><p><code>push eax</code></p><p><code>mov fs:[0],esp</code></p><p><code>pop eax</code></p><p><code>mov fs:[0],eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>mov ebp,eax</code></p><h4 id="5-Microsoft-Visual-C-6-0"><a href="#5-Microsoft-Visual-C-6-0" class="headerlink" title="5.Microsoft Visual C++ 6.0"></a>5.Microsoft Visual C++ 6.0</h4><p><code>PUSH -1</code></p><p><code>PUSH 0</code></p><p><code>PUSH 0</code></p><p><code>MOV EAX,DWORD PTR FS:[0]</code></p><p><code>PUSH EAX</code></p><p><code>MOV DWORD PTR FS:[0],ESP</code></p><p><code>SUB ESP,68</code></p><p><code>PUSH EBX</code></p><p><code>PUSH ESI</code></p><p><code>PUSH EDI</code></p><p><code>POP EAX</code></p><p><code>POP EAX</code></p><p><code>POP EAX</code></p><p><code>ADD ESP,68</code></p><p><code>POP EAX</code></p><p><code>MOV DWORD PTR FS:[0],EAX</code></p><p><code>POP EAX</code></p><p><code>POP EAX</code></p><p><code>POP EAX</code></p><p><code>POP EAX</code></p><p><code>MOV EBP,EAX</code></p><p><code>JMP 原入口</code></p><h4 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h4><p><code>在mov ebp,eax</code></p><p><code>后面加上</code></p><p><code>PUSH EAX</code></p><p><code>POP EAX</code></p><h4 id="7-防杀精灵一号防杀代码"><a href="#7-防杀精灵一号防杀代码" class="headerlink" title="7.防杀精灵一号防杀代码"></a>7.防杀精灵一号防杀代码</h4><p><code>push ebp</code></p><p><code>mov ebp,esp</code></p><p><code>push -1</code></p><p><code>push 666666</code></p><p><code>push 888888</code></p><p><code>mov eax,dword ptr fs:[0]</code></p><p><code>push eax</code></p><p><code>mov dword ptr fs:[0],esp</code></p><p><code>pop eax</code></p><p><code>mov dword ptr fs:[0],eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>mov ebp,eax</code></p><p><code>jmp 入口</code></p><h4 id="8-防杀精灵二号防杀代码"><a href="#8-防杀精灵二号防杀代码" class="headerlink" title="8.防杀精灵二号防杀代码"></a>8.防杀精灵二号防杀代码</h4><p><code>push ebp</code></p><p><code>mov ebp,esp</code></p><p><code>push -1</code></p><p><code>push 0</code></p><p><code>push 0</code></p><p><code>mov eax,dword ptr fs:[0]</code></p><p><code>push eax</code></p><p><code>mov dword ptr fs:[0],esp</code></p><p><code>sub esp,68</code></p><p><code>push ebx</code></p><p><code>push esi</code></p><p><code>push edi</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>add esp,68</code></p><p><code>pop eax</code></p><p><code>mov dword ptr fs:[0],eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>pop eax</code></p><p><code>mov ebp,eax</code></p><p><code>jmp 入口</code></p><h4 id="9-防杀精灵终极防杀代码"><a href="#9-防杀精灵终极防杀代码" class="headerlink" title="9.防杀精灵终极防杀代码"></a>9.防杀精灵终极防杀代码</h4><p><code>push ebp</code></p><p><code>mov ebp,esp</code></p><p><code>add esp,-0C</code></p><p><code>add esp,0C</code></p><p><code>push eax</code></p><p><code>jmp入口</code></p><h4 id="10-木马彩衣-金色鱼锦衣-花代码"><a href="#10-木马彩衣-金色鱼锦衣-花代码" class="headerlink" title="10.木马彩衣(金色鱼锦衣)花代码"></a>10.木马彩衣(金色鱼锦衣)花代码</h4><p><code>push ebp</code></p><p><code>mov ebp,esp</code></p><p><code>add esp,-0C</code></p><p><code>add esp,0C</code></p><p><code>mov eax,原入口</code></p><p><code>push eax</code></p><p><code>retn</code></p><h4 id="11-木马彩衣-虾米披风-花代码"><a href="#11-木马彩衣-虾米披风-花代码" class="headerlink" title="11.木马彩衣(虾米披风)花代码"></a>11.木马彩衣(虾米披风)花代码</h4><p><code>push ebp</code></p><p><code>nop</code></p><p><code>nop</code></p><p><code>mov ebp,esp</code></p><p><code>inc ecx</code></p><p><code>nop</code></p><p><code>push edx</code></p><p><code>nop</code></p><p><code>nop</code></p><p><code>pop edx</code></p><p><code>nop</code></p><p><code>pop ebp</code></p><p><code>inc ecx</code></p><p><code>loopd //跳转到下面那段代码地址去！</code></p><hr><p><code>nop //&quot;胡乱&quot;跳转的开始...</code></p><p><code>jmp 下一个jmp的地址 //在附近随意跳</code></p><p><code>jmp ... //...</code></p><p><code>jmp 原入口的地址 //跳到原始oep</code></p><h4 id="12-VC-5-0代码-木马彩衣无限复活袍"><a href="#12-VC-5-0代码-木马彩衣无限复活袍" class="headerlink" title="12.VC++5.0代码(木马彩衣无限复活袍):"></a>12.VC++5.0代码(木马彩衣无限复活袍):</h4><p><code>PUSH EBP</code></p><p><code>MOV EBP,ESP</code></p><p><code>PUSH -1</code></p><p><code>push 415448 -\___</code></p><p><code>PUSH 4021A8 -// 在这段代码中类似这样的操作数可以乱填</code></p><p><code>MOV EAX,DWORD PTR FS:[0]</code></p><p><code>PUSH EAX</code></p><p><code>MOV DWORD PTR FS:[0],ESP</code></p><p><code>ADD ESP,-6C</code></p><p><code>PUSH EBX</code></p><p><code>PUSH ESI</code></p><p><code>PUSH EDI</code></p><p><code>ADD BYTE PTR DS:[EAX],AL //这条指令可以不要!</code></p><p><code>jo 00401000 //原入口</code></p><p><code>jno 00401000 //原入口</code></p><p><code>db 0e8h //花代码</code></p>]]></content>
      
      
      <categories>
          
          <category> 逆向工程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>rc4学习</title>
      <link href="/2019/11/29/rc4%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/11/29/rc4%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>RC4是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。RC4是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。<br>流密码结构：<br><img src="https://s2.ax1x.com/2019/11/29/QkXROO.png" alt></p><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><p>下面这个图是rc4的流程图：<br><img src="https://s2.ax1x.com/2019/11/29/QkXj0g.png" alt><br>1、先初始化状态向量S（256个字节，用来作为密钥流生成的种子1）</p><p>按照升序，给每个字节赋值0,1,2,3,4,5,6…..,254,255</p><p>2、初始密钥（由用户输入），长度任意</p><p>如果输入长度小于256个字节，则进行轮转，直到填满</p><p>例如输入密钥的是1,2,3,4,5   ,  那么填入的是1,2,3,4,5,1,2,3,4,5,1,2,3,4,5……..</p><p>由上述轮转过程得到256个字节的向量T（用来作为密钥流生成的种子2）</p><p>3、开始对状态向量S进行置换操作（用来打乱初始种子1）</p><p>按照下列规则进行</p><p>从第零个字节开始，执行256次，保证每个字节都得到处理</p><p>　j = 0;</p><p>　　for (i = 0 ; i &lt; 256 ; i++){</p><p>　　　　j = (j + S[i] + T[i]) mod 256;</p><p>　　　　swap(S[i] , S[j]);</p><p>　　}</p><p>这样处理后的状态向量S几乎是带有一定的随机性了<br>4、最后是秘钥流的生成与加密，很多人在这里不是特别理解，别的博客也没有写的很简洁明了</p><p>假设我的明文字节数是datalength=1024个字节（当然可以是任意个字节）</p><p>i=0;</p><p>j=0;</p><p>while(datalength–){//相当于执行1024次，这样生成的秘钥流也是1024个字节</p><p>　　　i = (i + 1) mod 256;</p><p>　　　　j = (j + S[i]) mod 256;</p><p>　　　　swap(S[i] , S[j]);</p><p>　　　　t = (S[i] + S[j]) mod 256;</p><p>　　　　k = S[t];这里的K就是当前生成的一个秘钥流中的一位</p><p>　　　　//可以直接在这里进行加密，当然也可以将密钥流保存在数组中，最后进行异或就ok</p><p>　　　　data[]=data[]^k； //进行加密，”^”是异或运算符</p><p>}</p><p>解密按照前面写的，异或两次就是原文，所以只要把密钥流重新拿过来异或一次就能得到原文了</p><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><p>RC4算法的原理很简单，包括初始化算法（KSA）和伪随机子密码生成算法（PRGA)两大部分。假设S-box的长度为256，密钥长度为Len。先来看看算法的初始化部分（用C代码表示）： [1]<br>其中，参数1是一个256长度的char型数组，定义为: unsigned char sBox[256];<br>参数2是密钥，其内容可以随便定义：char key[256];<br>参数3是密钥的长度，Len = strlen(key);</p><pre><code>/*初始化函数*/void rc4_init(unsigned char*s,unsigned char*key, unsigned long Len){    int i=0,j=0;    //char k[256]={0};    unsigned char k[256]={0};    unsigned char tmp=0;    for(i=0;i&lt;256;i++) {        s[i]=i;        k[i]=key[i%Len];    }    for(i=0;i&lt;256;i++) {        j=(j+s[i]+k[i])%256;        tmp=s[i];        printf(&quot;copy for dongdeng&quot;);        s[i]=s[j];//交换s[i]和s[j]        s[j]=tmp;    }}</code></pre><p>在初始化的过程中，密钥的主要功能是将S-box搅乱，i确保S-box的每个元素都得到处理，j保证S-box的搅乱是随机的。而不同的S-box在经过伪随机子密码生成算法的处理后可以得到不同的子密钥序列，将S-box和明文进行xor运算，得到密文，解密过程也完全相同。<br>再来看看算法的加密部分（用C代码表示）：<br>其中，参数1是上边rc4_init函数中，被搅乱的S-box;<br>参数2是需要加密的数据data;<br>参数3是data的长度.</p><pre><code>/*加解密*/void rc4_crypt(unsigned char*s,unsigned char*Data,unsigned long Len){    int i=0,j=0,t=0;    unsigned long k=0;    unsigned char tmp;    for(k=0;k&lt;Len;k++)    {        i=(i+1)%256;        j=(j+s[i])%256;        tmp=s[i];        s[i]=s[j];//交换s[x]和s[y]        s[j]=tmp;        t=(s[i]+s[j])%256;        Data[k]^=s[t];    }}</code></pre><p>最后，在main函数中，调用顺序如下：</p><pre><code>int main(){unsigned char s[256]={0},s2[256]={0};//S-boxchar key[256]={&quot;justfortest&quot;};char pData[512]=&quot;这是一个用来加密的数据Data&quot;;unsigned long len=strlen(pData);int i;printf(&quot;pData=%s\n&quot;,pData);printf(&quot;key=%s,length=%d\n\n&quot;,key,strlen(key));rc4_init(s,(unsigned char*)key,strlen(key));//已经完成了初始化printf(&quot;完成对S[i]的初始化，如下：\n\n&quot;);for(i=0;i&lt;256;i++){    printf(&quot;%02X&quot;,s[i]);    if(i&amp;&amp;(i+1)%16==0)putchar(&#39;\n&#39;);}printf(&quot;\n\n&quot;);for(i=0;i&lt;256;i++)//用s2[i]暂时保留经过初始化的s[i]，很重要的！！！{    s2[i]=s[i];}printf(&quot;已经初始化，现在加密:\n\n&quot;);rc4_crypt(s,(unsigned char*)pData,len);//加密printf(&quot;pData=%s\n\n&quot;,pData);printf(&quot;已经加密，现在解密:\n\n&quot;);//rc4_init(s,(unsigned char*)key,strlen(key));//初始化密钥rc4_crypt(s2,(unsigned char*)pData,len);//解密printf(&quot;pData=%s\n\n&quot;,pData);return0;}</code></pre><p>最终的完整程序是：</p><pre><code>//程序开始#include&lt;stdio.h&gt;#include&lt;string.h&gt;typedef unsigned longULONG; /*初始化函数*/void rc4_init(unsigned char*s, unsigned char*key, unsigned long Len){    int i = 0, j = 0;    char k[256] = { 0 };    unsigned char tmp = 0;    for (i = 0; i&lt;256; i++)    {        s[i] = i;        k[i] = key[i%Len];    }    for (i = 0; i&lt;256; i++)    {        j = (j + s[i] + k[i]) % 256;        tmp = s[i];        s[i] = s[j];//交换s[i]和s[j]        s[j] = tmp;    }}/*加解密*/void rc4_crypt(unsigned char*s, unsigned char*Data, unsigned long Len){    int i = 0, j = 0, t = 0;    unsigned long k = 0;    unsigned char tmp;    for (k = 0; k&lt;Len; k++)    {        i = (i + 1) % 256;        j = (j + s[i]) % 256;        tmp = s[i];        s[i] = s[j];//交换s[x]和s[y]        s[j] = tmp;        t = (s[i] + s[j]) % 256;        Data[k] ^= s[t];    }}int main(){    unsigned char s[256] = { 0 }, s2[256] = { 0 };//S-box    char key[256] = { &quot;justfortest&quot; };    char pData[512] = &quot;这是一个用来加密的数据Data&quot;;    unsigned long len = strlen(pData);    int i;         printf(&quot;pData=%s\n&quot;, pData);    printf(&quot;key=%s,length=%d\n\n&quot;, key, strlen(key));    rc4_init(s, (unsigned char*)key, strlen(key));//已经完成了初始化    printf(&quot;完成对S[i]的初始化，如下：\n\n&quot;);    for (i = 0; i&lt;256; i++)    {        printf(&quot;%02X&quot;, s[i]);        if (i &amp;&amp; (i + 1) % 16 == 0)putchar(&#39;\n&#39;);    }    printf(&quot;\n\n&quot;);    for (i = 0; i&lt;256; i++)//用s2[i]暂时保留经过初始化的s[i]，很重要的！！！    {        s2[i] = s[i];    }    printf(&quot;已经初始化，现在加密:\n\n&quot;);    rc4_crypt(s, (unsigned char*)pData, len);//加密    printf(&quot;pData=%s\n\n&quot;, pData);    printf(&quot;已经加密，现在解密:\n\n&quot;);    //rc4_init(s,(unsignedchar*)key,strlen(key));//初始化密钥    rc4_crypt(s2, (unsigned char*)pData, len);//解密    printf(&quot;pData=%s\n\n&quot;, pData);    return 0;}//程序完</code></pre>]]></content>
      
      
      <categories>
          
          <category> crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019 nctf wp</title>
      <link href="/2019/11/29/2019-nctf-wp/"/>
      <url>/2019/11/29/2019-nctf-wp/</url>
      
        <content type="html"><![CDATA[<h1 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h1><p>动态调试即可，发现函数最后要和s比较，s经过多次加密。<br><img src="https://s2.ax1x.com/2019/11/29/Qkh1IO.png" alt><br>上图cmp dl,al就是比较过程.<br>动态调试看寄存中的值就可以得到flag。<br>本道题有一个值得学习的算法在rc4上</p><blockquote><p><a href="https://odoiys.github.io/2019/11/29/rc4%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener" title="rc4学习">https://odoiys.github.io/2019/11/29/rc4%E5%AD%A6%E4%B9%A0/</a></p></blockquote><h1 id="签到题"><a href="#签到题" class="headerlink" title="签到题"></a>签到题</h1><p>使用z3求解器</p><pre><code>from z3 import *a = [12, 83, 78, 39, 23, 27, 4, 53, 85, 53, 78, 6, 85, 6, 6, 12, 24, 52, 14, 92, 3, 34, 73, 36, 9, 74, 42, 67, 58, 27, 86, 62, 48, 48, 0, 36, 96, 25, 37, 12, 15, 26, 1, 52, 46, 84, 83, 72, 68]b = [18564,37316,32053,33278,23993,33151,15248,13719,34137,27391,28639,18453,28465,12384,20780,45085,35827,37243,26037,39409,17583,20825,44474,35138,36914,25918,38915,17672,21219,43935,37072,39359,27793,41447,18098,21335,46164,38698,39084,29205,40913,19117,21786,46573,38322,41017,29298,43409,19655]s = Solver()key = [BitVec(&#39;u%d&#39;%i,8) for i in range(49)]for i in range(7):    for j in range(7):        s.add(b[i*7+j] == key[i*7]*a[j]+key[i*7+1]*a[7*1+j]+key[i*7+2]*a[7*2+j]+key[i*7+3]*a[7*3+j]+key[i*7+4]*a[7*4+j]+key[i*7+5]*a[7*5+j]+key[i*7+6]*a[7*6+j])flag = &#39;&#39;if s.check() == sat:    result = s.model()    for i in range(49):        flag += chr(result[key[i]].as_long().real)    print flag</code></pre><p>z3有问题可以看这个链接<br><a href="https://ericpony.github.io/z3py-tutorial/guide-examples.htm" target="_blank" rel="noopener" title="z3求解器手册">https://ericpony.github.io/z3py-tutorial/guide-examples.htm</a></p>]]></content>
      
      
      <categories>
          
          <category> re wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019 赛博ctf wp</title>
      <link href="/2019/11/13/2019-%E8%B5%9B%E5%8D%9Actf-wp/"/>
      <url>/2019/11/13/2019-%E8%B5%9B%E5%8D%9Actf-wp/</url>
      
        <content type="html"><![CDATA[<h1 id="TEA"><a href="#TEA" class="headerlink" title="TEA"></a>TEA</h1><p>放到detectit看一下文件<br><img src="https://s2.ax1x.com/2019/11/13/MJof2R.png" alt><br>MFC类型</p><blockquote><p>微软基础类库（英语：Microsoft Foundation Classes，简称MFC）是微软公司提供的一个类库（class libraries），以C++类的形式封装了Windows API，并且包含一个应用程序框架，以减少应用程序开发人员的工作量。其中包含大量Windows句柄封装类和很多Windows的内建控件和组件的封装类。</p></blockquote><p>直接查看字符串<br><img src="https://s2.ax1x.com/2019/11/13/MJTZMq.png" alt><br>看到一个 flag正确<br>可以选择直接过去查看函数<br>F5直接看伪代码<br><img src="https://s2.ax1x.com/2019/11/13/MJTxfJ.png" alt><br>上图是该段代码最重要的部分<br>在这里，应该学习一下，这个是tea密码<br>（有空再来更新一下tea密码，电脑快没电了，逃<br>最后要和程序里的代码比较一下<br>最后贴上解密代码</p><p>`#include&lt;stdio.h&gt;<br>void decrypt(unsigned int <em>v, unsigned int *k)<br>{<br>    unsigned int v0 = v[0], v1 = v[1], sum = 0xc6ef3720, i;<br>    unsigned int delta = 0x9e3779b9;<br>    unsigned int k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];<br>    for (i = 0;i &lt; 32;i++)<br>    {<br>        v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3);<br>        v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1);<br>        sum -= delta;<br>    }<br>    v[0] = v0;<br>    v[1] = v1;<br>}<br>int main()<br>{<br>    unsigned int key[4] = { 1634103412,825438253,792290103,593654333 };<br>    unsigned int fis[8] = { 2287891615,1585311399,1546078125,467622186,705539630,739426750,3404744146,2450907267 };<br>    int j;<br>    for (j = 0; j &lt; 4; j++)<br>    {<br>        decrypt(&amp;fis[j * 2], key);<br>    }<br>    int i;<br>    for (i = 0; i &lt; 32; i++)<br>    {<br>        printf(“%c”, *(((char</em>)fis) + i));<br>    }<br>        system(“pause”);</p><p>}`</p><p>(有空更新一下pyhton的解密代码吧，这里先把ctfwiki上介绍的tea贴上去<br><a href="https://ctf-wiki.github.io/ctf-wiki/reverse/Identify-Encode-Encryption/introduction-zh/" target="_blank" rel="noopener" title="ctfwiki">https://ctf-wiki.github.io/ctf-wiki/reverse/Identify-Encode-Encryption/introduction-zh/</a></p><h1 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h1><p>放到detectit,如下：<br><img src="https://s2.ax1x.com/2019/11/14/MtLJat.png" alt><br>先查看主函数里的内容<br><img src="https://s2.ax1x.com/2019/11/14/MtLRRU.png" alt><br>需要仔细研究的函数有checktime(),check(&amp;s),run(&amp;s),key(&amp;s,90)应该是对字符串的输入<br>先来查看checktime()<br><img src="https://s2.ax1x.com/2019/11/14/MtOPFP.png" alt><br>这个应该算是方程组的求解可以算出来对应的值（要用线代，但也可以不用，建议尝试z3求解器，真的是神器）<br>看一下求解的代码</p><pre><code>from z3 import *solver = Solver()v4 = Int(&#39;v4&#39;)v5 = Int(&#39;v5&#39;)v6 = Int(&#39;v6&#39;)v7 = Int(&#39;v7&#39;)v8 = Int(&#39;v8&#39;)v9 = Int(&#39;v9&#39;)v10 = Int(&#39;v10&#39;)v11 = Int(&#39;v11&#39;)solver.add(14766 * v10 + 18242 * v9 + 4657 * v8 + 22453 * v7 + 7236 * v6 + 28554 * v5 + 25606 * v4 + 12289 * v11 == 12977737)solver.add(27429 * v10 + 8015 * v9 + 16511 * v8 + 17180 * v7 + 27141 * v6 + 31813 * v5 + 7412 * v4 + 18249 * v11 == 15081473)solver.add(2846 * v10 + 28353 * v9 + 19864 * v8 + 27377 * v7 + 9006 * v6 + 13657 * v5 + 19099 * v4 + 25835 * v11 == 13554960)solver.add(1078 * v10 + 5007 * v9 + 6568 * v8 + 23034 * v7 + 10150 * v6 + 22949 * v5 + 32646 * v4 + 15255 * v11 == 11284005)solver.add(8010 * v10 + 15430 * v9 + 6657 * v8 + 1009 * v7 + 25691 * v6 + 15960 * v5 + 19493 * v4 + 29491 * v11 == 10759932)solver.add(4605 * v10 + 14468 * v9 + 5017 * v8 + 12805 * v7 + 22973 * v6 + 30584 * v5 + 12620 * v4 + 32085 * v11 == 12085266)solver.add(7478 * v10 + 6524 * v9 + 25994 * v8 + 16215 * v7 + 12864 * v6 + 20574 * v5 + 8882 * v4 + 14794 * v11 == 11323393)solver.add(15263 * v10 + 8821 * v9 + 25489 * v8 + 9598 * v7 + 26847 * v6 + 5175 * v5 + 6515 * v4 + 27411 * v11 == 11677607)if solver.check() == sat:    m = solver.model()    print(m)</code></pre><p>算出来的答案<br>v6 = 97<br>v5 = 108<br>v7 = 103<br>v4 = 102<br>v8 = 123<br>v10 = 104<br>v11 = 51<br>v9 = 84<br>可以转成字符串先看一下，flag{Th3，应该是flag的前几位</p><blockquote><p>这里也咕咕一下，留空准备介绍下z3的学习</p></blockquote><p>再来看一下check(&amp;s)函数<br><img src="https://s2.ax1x.com/2019/11/14/MtXHgO.png" alt><br>这个算法必须看会，这个类似base64编码，这个是base58（可我为什么感觉这两编码的代码差别好大，看来要学习一下了）<br>可以用网上的base58编码解码把给的数转换一下。_sEcond_Be5t_Time_1s_n0w}<br>结束</p>]]></content>
      
      
      <categories>
          
          <category> re wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>i春秋 竞赛训练营</title>
      <link href="/2019/11/12/i%E6%98%A5%E7%A7%8B-%E7%AB%9E%E8%B5%9B%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
      <url>/2019/11/12/i%E6%98%A5%E7%A7%8B-%E7%AB%9E%E8%B5%9B%E8%AE%AD%E7%BB%83%E8%90%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="CrackMe01"><a href="#CrackMe01" class="headerlink" title="CrackMe01"></a>CrackMe01</h1><p><img src="https://s2.ax1x.com/2019/11/12/M112uR.png" alt><br>打开字符串的话很难找到我们想要的函数的位置，所以不采取这个方法。<br>我们可以通过找api函数的办法来找到我们加密的位置。<br>这个时候需要打开输入函数，找到defwindowproc，这个api的功能是：</p><blockquote><p>调用重定向的窗口过程来为应用程序没有处理的任何窗口消息提供转换的处理。该函数确保每一个消息得到处理。</p></blockquote><p>这样我们双击来到这里<br><img src="https://s2.ax1x.com/2019/11/12/M132Rg.png" alt><br>右键查看外部引用<br><img src="https://s2.ax1x.com/2019/11/12/M18MY8.png" alt><br>一个一个查看，发现我们所需要的加密函数是在第一个交叉引用里面<br>进入函数<br><img src="https://s2.ax1x.com/2019/11/12/M1851e.png" alt><br>可以看到加密的函数有两个<br><code>do</code><br><code>{</code><br><code>*(&amp;chText + v12) ^ = v6;</code><br><code>v12 += 2;</code><br><code>}(v12 &lt; 44)</code></p><pre><code>if ( (v6 &amp; 0xF00) == 1024 &amp;&amp; (v6 &amp; 0xF0) == 176 &amp;&amp; (v6 &amp; 6) == 6 ){  showWindow((HWND)a1,5); UpdateWindow((HWND)a1);}</code></pre><p>根据这个加密函数，可写出解密函数:<br><code>for i in range(1,10000):</code><br>    <code>if(i &amp; 0xf00 == 1024):</code><br>        <code>if(i &amp; 0xf0 == 176):</code><br>            <code>if(i &amp; 6 == 6):</code><br>                <code>print(hex(i))</code><br><code>chText = [0x4F0, 0x4DA, 0x4D7, 0x4D1, 0x48C, 0x4FF, 0x4F5, 0x4FE, 0x4E3, 0x4F8, 0x4E7, 0x4FF, 0x4E3, 0x4E9, 0x4F0,0x4F3, 0x485, 0x480, 0x484, 0x4F2, 0x4F4, 0x4F3]</code><br><code>flag = &#39;&#39;</code><br><code>for i in range(22):</code><br>    <code>chText[i] ^= 0x4b6</code><br>    <code>flag += chr(chText[i])</code><br><code>print(flag)</code></p><p>总结：加密函数真的很简单了，但是这道题最让我困扰的是如何找到加密函数，今天学到了用api函数找到加密的位置，不给main函数是真的难受啊。网上的wp还有更麻烦的，有动态调试的，等等。看来要好好看一下win32编程了。顺便如果学会了动态调试的话，可以尝试用动态调试来解决问题，毕竟用动态调试跟踪系统函数的想法还是蛮不错的。</p>]]></content>
      
      
      <categories>
          
          <category> re wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>三叶草syc ctf </title>
      <link href="/2019/11/11/%E4%B8%89%E5%8F%B6%E8%8D%89syc-ctf/"/>
      <url>/2019/11/11/%E4%B8%89%E5%8F%B6%E8%8D%89syc-ctf/</url>
      
        <content type="html"><![CDATA[<h1 id="jiang’s-fan"><a href="#jiang’s-fan" class="headerlink" title="jiang’s fan"></a>jiang’s fan</h1><p>放入ida中，shift+f12查看字符串，就可以看到flag</p><h1 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h1><p>放入ida当中，查看主函数，看到base函数，函数中是对你输入的字符串进行base16加密，base16你可以理解为将字符串转换为16进制数字。main函数最后，将你输入的字符加密后和字符串比较，如果相同则输出正确。输入的字符为flag。可以用网上的base16进行解密，我当时做的时候用的爆破（主要是当时不知道base16。 解密代码先咕咕掉吧。等我会了在补上去</p><h1 id="冰菓"><a href="#冰菓" class="headerlink" title="冰菓"></a>冰菓</h1><p>放入detectit<br><img src="https://s2.ax1x.com/2019/11/17/MD8Jud.png" alt><br>.net文件，直接用dnspy来反编译<br>开始调试，设置中断在入口点，发现进入了bingo类里面，bingo类里面有个mainwindow，猜测是主函数可以进去看看。<br><img src="https://s2.ax1x.com/2019/11/17/MDGoJf.png" alt><br>里面有个encryptstr看上去像是加密类，先进去看看。<br><img src="https://s2.ax1x.com/2019/11/17/MDYB8K.png" alt><br>下面给了两个数组，然后进行了异或和相加的操作，直接写解密代码就可以了。<br>    code = [119,77,103,79,21,115,133,97,115,87,22,115,103,89,88,93,22,89,119,81]</p><pre><code>str = &#39;&#39;for i in range(len(code)):    str += chr((encode[i] - 13) ^ 0x39print(str)</code></pre><h1 id="dll-reverse"><a href="#dll-reverse" class="headerlink" title="dll reverse"></a>dll reverse</h1><p>dll文件不想多讲，百度都有。对于这道题来说直接把dll文件放进去分析就可以了。<br>很容易找到加密函数<br><img src="https://s2.ax1x.com/2019/11/17/MDNekn.png" alt><br>大概看一下，应该是base64再加上了一个异或的操作，结果也给了，直接逆向代码就可以得出要输入的代码了。还有一点要说的是base64中的对照表有一部分换了<br>下面是解密代码<br>    import base64</p><pre><code>list = bytes([69, 106, 67, 52, 86, 59, 79, 103, 71, 67, 25, 35, 67,117, 108, 103, 59, 101, 84, 70, 66, 55, 1, 80, 85, 96, 73, 36, 24, 74, 39, 31, 9, 29, 74, 0])list_1 = bytes([34, 89, 50, 94, 56, 11, 66, 86, 38, 112, 77, 69, 19, 34, 45, 29, 91, 55, 112, 3, 18, 96, 124, 54, 7, 83, 3, 83, 79,120, 86, 38, 0, 0, 0, 0])list_2 = []flag = &#39;&#39;for i in range(32):    if (i % 2 == 0):        list_2.append((list_1[i] - 3) ^ list[i])    else:        list_2.append((list_1[i] ^ list[i]))for i in range(len(list_2)):    flag += chr(list_2[i])table1 = &quot;ABCDEFGHIJKLMNOPQSVXZRWYTUeadbcfghijklmnopqrstuvwxyz0123456789+/&quot;table2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;print(base64.b64decode(flag.translate(flag.maketrans(table1,table2))))</code></pre><h1 id="EASY-VB"><a href="#EASY-VB" class="headerlink" title="EASY VB"></a>EASY VB</h1><p>当知道这是一个vb后，我尝试用vb decompiler pro来解决这道题，但发现这道题放进去后还是汇编函数，没办法反汇编。只能继续用ida pro进去读汇编。<br>shift + f12查找字符串，进去查找看看能有什么收获。<br><img src="https://s2.ax1x.com/2019/11/18/Ms7Y5Q.png" alt><br>这四句看起来比较关键，尤其是前面两句应该和flag有关，我们围绕这两句展开调查。<br><img src="https://s2.ax1x.com/2019/11/18/MsHwJH.png" alt><br>rtcMidCharVar，这是VB中⽤于截取字符串中字符的函数,⽽在下⼀个字符串赋值函数前,出现了jmp回到了rtcMidCharVar函数的上⽅,可知这是⼀个循环取字符的过程。<br><img src="https://s2.ax1x.com/2019/11/18/MsH2TS.png" alt><br>同理，在上方也可以发现有个rtcMidCharVar的函数和jmp的过程，猜测应该是对你输入的进行一一取值。<br><img src="https://s2.ax1x.com/2019/11/18/Msqu8J.png" alt><br>有一个将字符串转为ascii的函数，然后将eax和edx进行异或操作。得到的结果再和bKPObQ@goYBGRXjtVKVSn^@kFQh[V_]O进行比较。<br><img src="https://s2.ax1x.com/2019/11/18/MsqoZV.png" alt><br>这样就可以写出解密代码：<br>    import numpy as np</p><pre><code>a = &#39;bKPObQ@goYBGRXjtVKVSn^@kFQh[V_]O&#39;b = &#39;12345a789012345678g012345a789012&#39;a1 = np.fromstring(a,dtype=np.uint8)b1 = np.fromstring(b,dtype=np.uint8)flag = &#39;&#39;for i in xrange(len(a1)):    flag += chr(a1[i] ^ b1[i])print(flag)</code></pre><h1 id="re-py"><a href="#re-py" class="headerlink" title="re_py"></a>re_py</h1><pre><code>re_py源代码：print &quot;This is a maze.&quot;print &quot;Python is so easy.&quot;print &#39;Plz Input The Shortest Way:&#39;maze=&quot;###########S#@@@@@@##@#@####@##@#@@@@#@##@####@#@##@@@@@@#@#########@##E######@##@@@@@@@@###########&quot;way = raw_input()len = len(way)p=11for i in way:    if i==&quot;&amp;&quot;:        p-=10    if i==&quot;$&quot;:        p+=10    if i==&quot;6&quot;:        p-=1    if i==&quot;3&quot;:        p+=1    if maze[p]==&quot;#&quot;:        print &quot;Your way is wrong&quot;        exit(0)        break    if maze[p]==&quot;@&quot;:        continue    if maze[p]==&quot;E&quot;:    print &quot;You do it,your flag is Syc\{+Your Input+\}.&quot;    exit(0)print &quot;May be something wrong.&quot;</code></pre><p>从这里看来是一道迷宫题，十个字符为一行，&amp;是向上，$是向下，6是向左，3是向右<br>‘# # # # # # # # # #<br>‘# S # @ @ @ @ @ @ #<br>’# @ # @ # # # # @ #<br>‘# @ # @ @ @ @ # @ #<br>’# @ # # # # @ # @ #<br>‘# @ @ @ @ @ @ # @ #<br>’# # # # # # # # @ #<br>‘# E # # # # # # @ #<br>’# @ @ @ @ @ @ @ @ #<br>‘# # # # # # # # # #<br>根据图写出flag即可</p><h1 id="python1"><a href="#python1" class="headerlink" title="python1"></a>python1</h1><p>把文件放到python在线反编译当中，直接可以看到源代码</p><pre><code>源代码import structimport timedef b(a):    return a &amp; 0xFFFFFFFFFFFFFFFFdef c(str):    return struct.unpack(&#39;&lt;Q&#39;, str)[0]def d(a):    for i in range(64):        a = a * 2        if a &gt; 0xFFFFFFFFFFFFFFFF:            a = b(a)            a = b(a ^ 0xB0004B7679FA26B3)            continue    return aif __name__ == &#39;__main__&#39;:    cmp_data = [        0x6E8DD76D3B876F95,        0xE206DA09DAF4BED6,        0x77559D346E134BF1,        0x61CE39CAC5EAF891,        0x656C3C155520E36F]    input = input(&#39;plz input your flag:&#39;)    if len(input) % 8 != 0:        for i in range(8 - len(input) % 8):            input += &#39;\x00&#39;            arr = []    for i in range(len(input) // 8):        value = d(c(input[i * 8:i * 8 + 8]))        arr.append(value)    for i in range(5):        if arr[i] != cmp_data[i]:            print(&#39;fail&#39;)            time.sleep(5)            exit()            continue    print (&#39;success&#39;)    time.sleep(5)    exit()</code></pre><p>做题前⾸先熟悉python的使⽤，如struct.pack和struct.unpack，python和pyc⽂件反编译⽅⾯不多<br>提，Life is short, you need python。<br>题⽬的难点主要在于对d函数的逆向，会有64次乘⼆，每次乘2后还会进⾏判断，如果⼤于<br>0xffffffffffffffff，会&amp;0xffffffffffffffff再^ 0xB0004B7679FA26B3。<br>我们在些逆向脚本时候同样要进⾏64次的除以⼆，但是有个问题就是如何处理&amp;0xffffffffffffffff再^<br>0xB0004B7679FA26B3呢？<br>其实能看出来的话这道题就很简单了，⼊⼿点就是奇偶。<br>每次乘⼆后这⼀次循环得到的是偶数，每次&amp;0xffffffffffffffff再^ 0xB0004B7679FA26B3这⼀次循环得<br>到的都是奇数。我们写脚本进⾏64次循环除以⼆时候，先进⾏判断，如果是偶数就直接除以⼆，如果是<br>奇数就先^ 0xB0004B7679FA26B3，再+0xffffffffffffffff+1，再除以⼆即可。</p><pre><code>脚本：import structdef decode(a):    for i in range(64):        if(a%2 == 0):            a /= 2        else:            a ^=  0xB0004B7679FA26B3            a = a + 0xffffffffffffffff + 1            a /= 2    return aif __name__ == &#39;__main__&#39;:    cmp_data = [        0x6E8DD76D3B876F95,        0xE206DA09DAF4BED6,        0x77559D346E134BF1,        0x61CE39CAC5EAF891,        0x656C3C155520E36F]    flag = &#39;&#39;    for i in range(5):        flag += struct.pack(&quot;&gt;Q&quot;,decode(cmp_data[i]))[::-1].strip()        print(flag)</code></pre>]]></content>
      
      
      <categories>
          
          <category> re wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019 hectf re wp</title>
      <link href="/2019/11/06/2019-hectf-re-wp/"/>
      <url>/2019/11/06/2019-hectf-re-wp/</url>
      
        <content type="html"><![CDATA[<p>官方wp<br><a href="https://www.yuque.com/docs/share/e6c5d1fd-8d27-456a-88ab-823226503f56#helloRE" target="_blank" rel="noopener">https://www.yuque.com/docs/share/e6c5d1fd-8d27-456a-88ab-823226503f56#helloRE</a></p><h1 id="qiandao"><a href="#qiandao" class="headerlink" title="qiandao"></a>qiandao</h1><p>放在od中<br><img src="https://s2.ax1x.com/2019/11/06/MiV3QO.png" alt></p><h1 id="helloRe"><a href="#helloRe" class="headerlink" title="helloRe"></a>helloRe</h1><p>放在ida中，反编译<br><img src="https://s2.ax1x.com/2019/11/06/MiVMJx.png" alt><br>main函数：输入字符串，长度不能超过25，通过一个if语句即可获得success<br>查看sub_401080<br><img src="https://s2.ax1x.com/2019/11/06/MiV1SK.png" alt><br>sub_401080是对输入a1进行了处理<br>sub_401080的返回值是一个判断，函数sub_401000如果不等于0，则返回True<br>并且调用sub_401000时，传入经过处理的输入a1<br>进入sub_401000<br><img src="https://s2.ax1x.com/2019/11/06/MiVKF1.png" alt><br>if成立的条件是v3和输入相同，strcpy函数将aAy9ZZx9xoc9zI9复制给v3<br>阅读汇编可知<br><img src="https://s2.ax1x.com/2019/11/06/MiVQW6.png" alt><br>是经过sub_401080处理后的等于这一串字符串</p><p>明白后写出脚本：</p><pre><code>if __name__ == &quot;__main__&quot;:`f_flag = &#39;aY9)Z(?|ZX9xOC9z_i9eOYCw&#39;``flag = [0]*25``f_ord = [0]*25``for i in range(len(f_flag)):`   ` f_ord[i] = ord(f_flag[i])``for i in range(len(f_flag)):`    `if(f_ord[i]&gt;=40 and f_ord[i] &lt; 48):`        `flag[i] = f_ord[i] + 80`    `else:`        `if(f_ord[i]&gt;=62 and f_ord[i]&lt;=73):`            `flag[i] = f_ord[i] + 3`        `else:`            `if(f_ord[i]&gt;=79 and f_ord[i]&lt;92):`                `flag[i] = f_ord[i] -2`            `else:`                 `if(f_ord[i]&gt;=93 and f_ord[i]&lt;=107):`                    `flag[i] = f_ord[i] + 4`                `else:`                    `if(f_ord[i]&gt;=115 and f_ord[i]&lt;=125):`                        `flag[i] = f_ord[i] - 3`                    `else:`                        `if (f_ord[i] &lt; 38 and f_ord[i]&gt;29):`                            `flag[i] = f_ord[i] +1`                        `else:`                            `flag[i] = f_ord[i]``for i in range(len(flag)):`    `flag[i] = chr(flag[i])``flag1 = &#39;&#39;``for i in range(len(flag)):`    `flag1 += flag[i]``print(flag1)`  </code></pre><p>最后出来是eW91X0ByZV9uMF9wcm9iMWFt<br>最后进行base64解码<br>flag: flag{you_@re_n0_prob1am}</p>]]></content>
      
      
      <categories>
          
          <category> re wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>buuctf re wp</title>
      <link href="/2019/10/28/buuctf-re-wp/"/>
      <url>/2019/10/28/buuctf-re-wp/</url>
      
        <content type="html"><![CDATA[<h2 id="youngter-drive"><a href="#youngter-drive" class="headerlink" title="youngter-drive"></a>youngter-drive</h2><p><a href="https://hx1997.github.io/2018/07/22/anheng-july-re-youngter-drive/" target="_blank" rel="noopener">https://hx1997.github.io/2018/07/22/anheng-july-re-youngter-drive/</a></p><h2 id="crackRTF"><a href="#crackRTF" class="headerlink" title="crackRTF"></a>crackRTF</h2><p><a href="https://www.52pojie.cn/thread-994588-1-1.html" target="_blank" rel="noopener" title="wp">https://www.52pojie.cn/thread-994588-1-1.html</a><br>补充一些知识点：<br>有个PDB文件的类型</p><blockquote><p>PDB（Program Database File，程序数据库文件）文件物理结构在我们目前使用的掌上电脑中，Palm操作系统由于其功能强大、应用软件多等特点，占有很大的比例。PDB文件是Palm OS操作系统上数据文件类型。一般我们在使用Palm系统的电子书时都会遇到这种文件，一般用于电子书或手机电子书 pdb是Palm DataBase的缩写，Palm OS所用文件的扩展名为“.pdb”。还表示碳氧同位素标准样品以及可编程延迟模块，是DSP中的一种模块，可以用来计数和延时。<br>可以使用PalmReader打开。如果想把PDB文件转换成TXT文件查看，可以使用WavePDB转。<br><a href="https://baike.baidu.com/item/pdb/5357352" target="_blank" rel="noopener" title="具体内容">https://baike.baidu.com/item/pdb/5357352</a></p></blockquote><h2 id="GXYCTF2019-simple-CPP"><a href="#GXYCTF2019-simple-CPP" class="headerlink" title="[GXYCTF2019]simple CPP"></a>[GXYCTF2019]simple CPP</h2><p>先查看文件类型</p><p><img src="https://s2.ax1x.com/2020/01/18/1pnoBd.png" alt></p><p>用PEid看看是否有什么加密算法</p><p><img src="https://s2.ax1x.com/2020/01/18/1pnInH.png" alt></p><p>看来是没有</p><p>直接拖进ida64查看内容吧</p><p>有很多的函数，并且没有看到main函数，那就只能从字符串找找有什么突破口</p><p><img src="https://s2.ax1x.com/2020/01/18/1pnHAI.png" alt></p><p>看到congratulations了，看来这部分可能与flag有关系了，进去看看。</p><p><img src="https://s2.ax1x.com/2020/01/18/1pnTHA.png" alt></p><p>看到这个函数后，光读后面的部分就可以知道判断条件是什么，如下</p><pre><code>// v20 = 1176889593874// v20 = v15[2]&amp;~v15[0]// v24 = 4483974544037412639// v24=(v15[2]&amp;~v15[0])|(v15[1]&amp;v15[0])|(v15[2]&amp;~v15[1])|(v15[0]&amp;~v15[1])// v27=577031497978884115// v27=((v15[2]&amp;~v15[1])&amp;v15[0])|(v15[2]&amp;((v15[0]&amp;v15[1])|(v15[1]&amp;~v15[0])|~(v15[1]|v15[0])))// (v24 ^ v15[3]) == 4483974543195470111// v15[2]&amp;~v15[0]|v15[0]&amp;v15[1]|v15[1]&amp;v15[2] = ~v15[0]&amp;v15[2]|864693332579200012</code></pre><p>自己算的话不太可能，这时候可以借助z3求解器来解决计算问题代码如下：</p><pre><code>from z3 import *a,b,c,d=BitVecs(&#39;a b c d&#39;,64)s=Solver()s.add(~a&amp;c==1176889593874)s.add((c&amp;~a)|(b&amp;a)|(c&amp;~b)|(a&amp;~b)==4483974544037412639)s.add(((c&amp;~b)&amp;a)|(c&amp;((a&amp;b)|(b&amp;~a)|~(b|a)))==577031497978884115)s.add(((c&amp;~a)|(b&amp;a)|(c&amp;~b)|(a&amp;~b))^d==4483974543195470111)#print s.model()print s.check()print s.model()</code></pre><p>算出来的答案如下：</p><pre><code>sat[w = 842073600, y = 4483973367147818765, x = 4483973367147818765, z = 577031497978884115]</code></pre><p>感觉Y有点问题，不过先不管了。</p><p>把这几个数字转成十六进制再拼起来，后面会用到。</p><p>Y的部分直接都改成0x0</p><p><img src="https://s2.ax1x.com/2020/01/18/1pnX38.png" alt></p><p>上图的最下面的循环是很重要的一部分，是判断用来你输入是否是答案，这个v3就是刚才的v15，v7是上面的Dst，但是你没办法判断Dst的值，这时候看交叉引用来判断是哪个函数为它赋值的。如下图：</p><p><img src="https://s2.ax1x.com/2020/01/18/1pnvjg.png" alt></p><p>进去查看该函数</p><p><img src="https://s2.ax1x.com/2020/01/18/1pnzuQ.png" alt></p><p>读几个关键部分其实就能够知道Dst被赋值为”i_will_check_is_debug_or_not”</p><p>知道这些就够了，把我之前说的那个循环写个脚本就可以跑出来了。</p><p>脚本如下：</p><pre><code>a=&quot;i_will_check_is_debug_or_not&quot;b = [0x3e,0x3a,0x46,0x05,0x33,0x28,0x6f,0x0d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x08,0x2,0x07,0x17,0x15,0x3e,0x30,0x13,0x32,0x31,0x06,0x00,0x00]c=&#39;&#39;for i in range(0,27):        c += chr(ord(a[i%27])^b[i])print c</code></pre><p>y刚才说有问题，后来看官方wp应该是给hint补充了，这样子flag就出来了</p><blockquote><p>flag{We1l_D0ne!P0or_algebra_am_i}</p></blockquote><h2 id="findkey"><a href="#findkey" class="headerlink" title="findkey"></a>findkey</h2><p>放入detect it 检查发现是32位程序，而且是个PDB文件。</p><blockquote><p>PDB（Program Database File，程序数据库文件）文件物理结构在我们目前使用的掌上电脑中，Palm操作系统由于其功能强大、应用软件多等特点，占有很大的比例。PDB文件是Palm OS操作系统上数据<a href="https://baike.baidu.com/item/文件类型" target="_blank" rel="noopener">文件类型</a>。一般我们在使用Palm系统的电子书时都会遇到这种文件，一般用于电子书或手机电子书 pdb是Palm DataBase的缩写，Palm OS所用文件的扩展名为“.pdb”。</p></blockquote><p>但这里并不是重点。</p><p>再把它放到PEid中看一下有没有什么加密函数，</p><p><img src="https://s2.ax1x.com/2020/01/22/1AAby8.png" alt></p><p>点开细看可以看到是md5加密，md5的题目有需要爆破的可能性，再放到ida里看。</p><p>进入ida可以看到函数窗口里有winmain，进入看函数伪代码，应该是程序主界面的参数调整等，这部分不是很重要，接着往下看，看完所有函数的伪代码，只发现有一部分像加密的部分，如下图：</p><p><img src="https://s2.ax1x.com/2020/01/22/1AVeHg.png" alt></p><p>尝试跳转外部引用发现会跳转到一块汇编语言，左边是红色的部分可以猜测可能是花指令扰乱了正常汇编，先把左边的红色部分的地址用P键创建函数，然后发现有三个地方无法生成伪代码，先不管那些那些部分，先把生成的正常的部分看一下，有没有重要的部分。在寻找的过程中找到这个函数，</p><p><img src="https://s2.ax1x.com/2020/01/22/1AZ9qU.png" alt></p><p>v14和v18是重要的变量，进入sub_401005这个函数，</p><p><img src="https://s2.ax1x.com/2020/01/22/1AVeHg.png" alt></p><p>函数的算法加密过程并不难理解，两个参数都是已知的，就是v14和v18，可以写出脚本看一下，</p><pre><code class="python">key1=[]key=&#39;&#39;key2=&#39;0kk`d1a`55k222k2a776jbfgd`06cjjb&#39;for i in range(len(key2)):    key1.append(chr(ord(key2[i])^83))    key+=chr(ord(key2[i])^83)print(key)</code></pre><p>结果是 c8837b23ff8aaa8a2dde915473ce0991（也就是v18）</p><p>之后会经过一个strcmpi的函数进行比较</p><p>相等的话说明string1也是这个值，string1经过了一次md5的加密，这时候打开百度，查找md5解密可以破解出来string1的值应该为‘123321’</p><p>然后后面还有一个sub_401005，这次重点是v22和v13，v22是刚开始的string1也就是’123321’，v13就是那个byte_423030，然后根据这些可以写出脚本。</p><pre><code class="python">key1=&#39;123321&#39;key2=[87,94,82,84,73,95,1,109,105,70,2,110,95,2,108,87,91,84,76]key=&#39;&#39;for i in range(len(key2)):    key += chr(key2[i]^ord(key1[i%len(key1)]))print(key)</code></pre><p>结果是flag{n0_Zu0_n0_die}</p><p>这就是本次的答案</p><h2 id="SUCTF2019-SignIn"><a href="#SUCTF2019-SignIn" class="headerlink" title="[SUCTF2019]SignIn"></a>[SUCTF2019]SignIn</h2><p>本道题是一道RSA的题目有关RSA的算法可以上网查阅。</p><p>放到detectit查看是64位linux的文件，放到peid中查看是否有算法，看到有大数后可以猜测是RSA的算法。</p><p>进入ida查看程序</p><p><img src="https://s2.ax1x.com/2020/01/22/1EPzXF.png" alt></p><p>那个sub_96A不是重要的步骤，很容易懂，所以就不做分析了。</p><p>重要的是gmpz_init_set_str和gmpz_pown这两个函数，前者是用来初始化变量，后一个是将M的E次方模N放入M中。这两个函数是开源的数据库中的函数</p><blockquote><p>GMP，是GNU MP Bignum库的缩写，意思是开源数学运算库。GMP是GNU MP Bignum库，是一个开源的数学运算库，它可以用于任意精度的数学运算，包括有符号整数，有理数和浮点数。</p></blockquote><p>看来可以用来算大数运算。</p><p>前面分析了两个重要的函数的作用，再加上65537这些数字就已经可以确定是RSA了，直接按照破解rsa的流程就可以了。</p><p>首先要把大数N分解了，用yafu就可以了如下图：</p><p><img src="https://s2.ax1x.com/2020/01/22/1EFxZ4.png" alt></p><p>这样P和Q就知道了，还需要求欧拉函数，私钥，其实已经显而易见了，写个脚本就能出来了。</p><pre><code class="python">import gmpy2p = 366669102002966856876605669837014229419q = 282164587459512124844245113950593348271N = 103461035900816914121390101299049044413950405173712170434161686539878160984549c = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35e = 65537d = gmpy2.invert(e,(p-1)*(q-1))m = gmpy2.powmod(c,d,p*q)print hex(m)[2:].decode(&#39;hex&#39;)</code></pre><p>（说一下gmpy2的安装好麻烦233333~。）</p><h2 id="2019红帽杯-xx"><a href="#2019红帽杯-xx" class="headerlink" title="[2019红帽杯]xx"></a>[2019红帽杯]xx</h2><p>这题目花了我好长时间复现（因为真的是做不出来），不愧是最菜选手(哭)</p><p>放到detectit查看是64位PE文件，去peid中查看算法，发现是这么描述的</p><blockquote><p>A single DWORD, used in multiple crypto algorithms (TEA/N, RC 5/6, SERPENT, ISAAC, etc).</p></blockquote><p>看来有可能是tea类的或是RC类的算法加密等等。</p><p>进入ida细看一下吧</p><p>发现又是一堆函数，这时候只能查看字符串了，发现you win这个地方有可能和flag有关系，进入查看伪代码。</p><p>很长。。。。。。。</p><p>一部分一部分看吧</p><p>第一部分</p><p><img src="https://s2.ax1x.com/2020/01/31/133qhT.png" alt></p><p>这一部分是用来取出输入的flag的前四个字母，这个应该是众所周知的‘flag’的这四个字母，然后与code这个变量进行比较，是否是这个变量中的字母或数字。</p><p>第二部分：</p><p><img src="https://s2.ax1x.com/2020/01/31/13GlZR.png" alt></p><p>这一部分是进行xxtea的加密，其中sub_140001ab0就是加密的过程，这里就不放出来了，里面写的很复杂，不是很容易懂，这里放一个链接，大概了解一下xxtea原理</p><blockquote><p><a href="https://odoiys.github.io/2020/01/29/xxtea学习/" target="_blank" rel="noopener">https://odoiys.github.io/2020/01/29/xxtea%E5%AD%A6%E4%B9%A0/</a></p></blockquote><p>继续往下看第三部分：</p><p><img src="https://s2.ax1x.com/2020/01/31/13G5oq.png" alt></p><p>主要进行了将xxtea加密后的数组进行打乱，然后进行异或操作，最后进行和给出的&amp;v31,&amp;v31+1,&amp;v32,v33进行比较，这里是小端序，所以需要把它倒过拼接起来，拼接后的结果为：</p><p>CEBC406B7C3A95C0EF9B202091F70235231802C8E75656FA</p><p>过程清楚后写脚本来得到flag吧</p><pre><code class="python">import xxteadata0 = &quot;CEBC406B7C3A95C0EF9B202091F70235231802C8E75656FA&quot;#为提取出来的v29,v29+1,v30,v31data = []for i in range(0,len(data0),2):    data.append(int(data0[i]+data0[i+1],16))#每两位为整体，将16进制转换为10进制print(data)for i in range(len(data)-1,-1,-1):    for j in range(i//3):        data[i] ^= data[j]        #进行的异或操作print(data)change=[2,0,3,1,6,4,7,5,10,8,11,9,14,12,15,13,18,16,19,17,22,20,23,21]data1=[0 for i in range(24)]#print(data1)for i in range(24):    data1[change[i]]=data[i]print(data1)#encrypt_data=&#39;bca5ce40f4b2b2e7a9129d12ae10c85b3dd7061ddc70f8dc&#39;.decode(&#39;hex&#39;)#print(encrypt_data)key = &quot;flag&quot;encrypt_data=&#39;&#39;for i in range(len(data1)):    encrypt_data+=str(hex(data1[i]))print(encrypt_data)#bca5ce40f4b2b2e7a9129d12ae10c85b3dd761ddc70f8dcencrypt_data=&#39;bca5ce40f4b2b2e7a9129d12ae10c85b3dd7061ddc70f8dc&#39;.decode(&#39;hex&#39;)print(encrypt_data)key=&#39;flag\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#39;decrypt_data = xxtea.decrypt(encrypt_data,key,padding=False)#decrypt_data = xxtea.decrypt(encrypt_data,key)print decrypt_data</code></pre><p>这样就可以得到flag了</p><p>那阵还看到脚本更强的，还有把xxtea直接写出来，还有动态调试读流程的，简直无敌。</p><p>flag{CXX_and_++tea}</p><h2 id="GWCTF-2019-re3"><a href="#GWCTF-2019-re3" class="headerlink" title="[GWCTF 2019]re3"></a>[GWCTF 2019]re3</h2><p>放入detectit中可以看到是elf64，再放到peid中查看有哪些加密，md5,aes,base64，感觉很复杂的样子，进入ida64里看一下。</p><p><img src="https://s2.ax1x.com/2020/01/31/18MDN8.png" alt></p><p>直接进入main函数，看到一个异或操作，这个操作是用来把函数内容变换，这样子就没办法静态直接看到，可以选择用ida远程调试linux来动态查看sub_402219的真正面貌，之前还有个sub_40207b那个函数并没有对输入进行改变暂时不用看。sub_402219如下：<br><img src="https://s2.ax1x.com/2020/01/31/18Qu8g.png" alt></p><p>v4就是aes的key，byte_6030a0就是aes的加密结果，然后可以写脚本来解密：</p><pre><code class="python">from Crypto.Cipher import AEScipher1 = [0xBC, 0x0A, 0xAD, 0xC0, 0x14, 0x7C, 0x5E, 0xCC, 0xE0, 0xB1, 0x40, 0xBC, 0x9C, 0x51, 0xD5, 0x2B, 0x46, 0xB2, 0xB9, 0x43, 0x4D, 0xE5, 0x32, 0x4B, 0xAD, 0x7F, 0xB4, 0xB3, 0x9C, 0xDB, 0x4B, 0x5B]key1 = [0xcb, 0x8d, 0x49, 0x35, 0x21, 0xb4, 0x7a, 0x4c, 0xc1, 0xae, 0x7e, 0x62, 0x22, 0x92, 0x66, 0xce]#cipher = bytes(cipher1)cipher=&#39;\xBC\x0A\xAD\xC0\x14\x7C\x5E\xCC\xE0\xB1\x40\xBC\x9C\x51\xD5\x2B\x46\xB2\xB9\x43\x4D\xE5\x32\x4B\xAD\x7F\xB4\xB3\x9C\xDB\x4B\x5B&#39;#key = bytes(key1)key=&#39;\xcb\x8d\x49\x35\x21\xb4\x7a\x4c\xc1\xae\x7e\x62\x22\x92\x66\xce&#39;print(key)aes = AES.new(key, mode=AES.MODE_ECB)flag = aes.decrypt(cipher)print(flag)</code></pre><p>flag{924a9ab2163d390410d0a1f670}</p><p>下次一定更一下aes的原理，以上只是简单写一下wp的流程。下次一定下次一定。</p><p>emm，下面是AES的介绍，可以大概学习一下</p><blockquote><p><a href="https://odoiys.github.io/2020/02/01/AES加密学习/" target="_blank" rel="noopener">https://odoiys.github.io/2020/02/01/AES%E5%8A%A0%E5%AF%86%E5%AD%A6%E4%B9%A0/</a></p></blockquote><h2 id="GUET-CTF2019-re"><a href="#GUET-CTF2019-re" class="headerlink" title="[GUET-CTF2019]re"></a>[GUET-CTF2019]re</h2><p>用detectit查看是个elf64并且有UPX壳，用UPX工具自动脱壳，用PEID查看没有加密算法。进入ida查看代码。</p><p>并没有发现main函数，只能查找字符串来寻找信息。发现input your flag，correct等，就进到这里查看伪代码。</p><p><img src="https://s2.ax1x.com/2020/02/01/1GAbsf.png" alt></p><p>查看if判断的那个函数，参数是&amp;v1</p><p><img src="https://s2.ax1x.com/2020/02/01/1GEiLT.png" alt></p><p>直接写脚本就可以求得</p><pre><code class="python">a=[0 for i in range(31)]a[0] = 166163712//1629056a[1] = 731332800//6771600a[2] = 357245568//3682944a[3] = 1074393000//10431000a[4] = 489211344//3977328a[5] = 518971936//5138336a[6] = 406741500//7532250a[7] = 294236496//5551632a[8] = 177305856//3409728a[9] = 650683500//13013670a[10] = 298351053//6088797a[11] = 386348487//7884663a[12] = 438258597//8944053a[13] = 249527520//5198490a[14] = 445362764//4544518a[15] = 981182160//10115280a[16] = 174988800//3645600a[17] = 493042704//9667504a[18] = 257493600//5364450a[19] = 767478780//13464540a[20] = 312840624//5488432a[21] = 1404511500//14479500a[22] = 316139670//6451830a[23] = 619005024//6252576a[24] = 372641472//7763364a[25] = 373693320//7327320a[26] = 498266640//8741520a[27] = 452465676//8871876a[28] = 208422720//4086720a[29] = 515592000//9374400a[30] = 719890500//5759124#a[31] = 357245568//3682944flag=&#39;&#39;for i in range(len(a)):    flag+=chr(a[i])print(flag)</code></pre><p>注意原函数中并没有a1[6]，所以我选择一个一个试出来发现1是答案。</p><p>flag{e165421110ba03099a1c039337}</p>]]></content>
      
      
      <categories>
          
          <category> re wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows下的异常处理</title>
      <link href="/2019/10/26/Windows%E4%B8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2019/10/26/Windows%E4%B8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>本章介绍两中技术，一是SEH(结构化异常处理),二是VEH(向量化异常处理)</p><h1 id="一，异常处理的基本概念"><a href="#一，异常处理的基本概念" class="headerlink" title="一，异常处理的基本概念"></a>一，异常处理的基本概念</h1><p>中断：是由外部硬件设备或异步事件产生的。<br>异常：是由内部事件产生的，又可分为故障，陷阱和终止。</p><h2 id="1-异常列表"><a href="#1-异常列表" class="headerlink" title="1)异常列表"></a>1)异常列表</h2><p>除了CPU能够捕获一个事件并引发一个硬件异常外，在代码中可以主动引发一个软件异常，这只需要调用RaiseException()函数，实例如下：<br>void RaiseException(DWORD dwExceptionCode,//标识所引发的异常的代码<br>                    DWORD dwExceptionFlags,//异常是否继续执行的标识<br>                    DWORD nNumberOfArguments,//附加信息<br>                    CONST DWORD *lpArguments);//附加信息</p><h2 id="2-异常处理的基本过程"><a href="#2-异常处理的基本过程" class="headerlink" title="2)异常处理的基本过程"></a>2)异常处理的基本过程</h2>]]></content>
      
      
      <categories>
          
          <category> 加密与解密学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PE文件</title>
      <link href="/2019/10/21/PE%E6%96%87%E4%BB%B6/"/>
      <url>/2019/10/21/PE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>PE文件的全称是便携式可执行文件，意为可移植的替换的文件，常见的EXE，DLL，OCX，SYS，COM都是PE文件，PE文件是Microsoft Windows操作系统上的程序文件（可能是间接被执行，如DLL）<br><img src="https://i.imgur.com/RfcvH1I.jpg" alt></p><blockquote><p>基地址定义：当PE文件通过Windows加载器被装入内存后，内存中的版本被称作模块（Module）。映射文件的起始地址被称作模块句柄（hMoudule），可以通过模块句柄访问其他的数据结构。这个初始内存弟子就是基地址。<br>内存中的模块代表着进程从这个可执行文件中所需要的代码，数据，资源，输入表，输出表以及其他有用的数据结构所使用的内存都放在一个连续的内存块中，编程人员只要知道装载程序文件映像到内存的基地址即可。在32位系统中可以直接调用GetModuleHandle以取得指向DLL的指针，通过指针访问DLL module的内容，例如：<br>HMODULE GetmoduleHandle（LPCTSRT lpModuleName）；<br>当调用该函数时，传递一个可执行文件或者DLL文件名字字符串。如果系统找到该文件，则返回该可执行文件的或者DLL文件映像加载到的基地址。也可以调用GetModuleHandle,传递NULL参数，则返回调用的可执行文件的基地址。<br>相对虚拟地址:在可执行文件中，有相当多的地方需要指定内存的地址。例如：引用全局变量时，需要指定它的地址。PE文件尽管有一个首选的载入地址（基地址）,但是他们可以载入到进程空间的任意地方，所以不能依赖与PE的载入点。由于这个原因，必须有一个方法来指定一个地址而不是依赖于PE载入点。<br>为了在PE文件中避免有确定的内存地址，出现了相对虚拟地址(Relative Virtual Addres,简称RVA)的概念。RVA只是内存中的一个简单的相对于PE文件装入地址的偏移地址，它是一个“相对”地址，或者称位“偏移量”地址。例如：假设一个EXE文件从地址40000h处载入，并且它的代码区块开始于4010000h，代码区的RVA将是：<br>目标地址401000h ——转入地址400000h则RVA=1000h。<br>将RVA地址转换成真实地址，只需简单的翻转这个过程：将实际装入地址加上RVA即可得到实际的内存地址。顺便一提，在PE用语里，实际的内存地址被称作虚拟地址(Vritual Address，简称VA)，另外也可以把虚拟地址想象为加上首选装入地址的RVA。不要忘了前面提到的装入地址等同于模块句柄，它们之间的关系如下：<br>虚拟地址(VA)=基地址（ImageBase）+相对虚拟地址(RVA)</p></blockquote><h2 id="1）MS-DOS头部"><a href="#1）MS-DOS头部" class="headerlink" title="1）MS-DOS头部"></a>1）MS-DOS头部</h2><p>每个PE文件是以一个DOS程序开始的，有了它，一旦程序在DOS下执行，DOS就能辨别出这是个有效的执行体，然后运行紧随MZ header（后面会介绍）之后的DOS stub(DOS块)。DOS stub实际上是一个有效的EXE，在不支持PE文件格式的操作系统中，它将简单显示一个错误提示，类似于字符串“This Program cannot be run in MS-DOS”。用户通常对DOS stub 不感兴趣，因为大多数情况下他们由汇编器自动生成。平常把DOS stub和DOS MZ头部合称为DOS文件头。</p><p>PE文件的第一个字节起始于一个传统的MS-DOS头部，被称作IMAGE_DOS_HEADER。其IMAGE_DOS_HEADER的结构如下（左边的数字是到文件头的偏移量）：</p><pre><code>        IMAGE_DOS_HEADER STRUCT </code></pre><p>​<br>    { </p><pre><code>+0h WORD e_magic   // Magic DOS signature MZ(4Dh 5Ah) DOS可执行文件标记 +2h   WORD  e_cblp  // Bytes on last page of file+4h WORD  e_cp   // Pages in file +6h WORD  e_crlc   // Relocations +8h WORD  e_cparhdr   // Size of header in paragraphs +0ah WORD  e_minalloc  // Minimun extra paragraphs needs +0ch WORD  e_maxalloc  // Maximun extra paragraphs needs +0eh WORD  e_ss// intial(relative)SS value  DOS代码的初始化堆栈SS +10h WORD  e_sp// intial SP value DOS代码的初始化堆栈指针SP +12h WORD  e_csum// Checksum +14h WORD  e_ip//intial IP value DOS代码的初始化指令入口[指针IP] +16h WORD  e_cs// intial(relative)CS valueDOS代码的初始堆栈入口 +18h WORD  e_lfarlc// File Address of relocation table +1ah WORD  e_ovno//Overlay number +1ch WORD  e_res[4]// Reserved words +24h WORD  e_oemid//OEM identifier(for e_oeminfo) +26h WORD  e_oeminfo   //OEM information;e_oemid specific  +29h WORD  e_res2[10]   //Reserved words +3ch DWORD   e_lfanew // Offset to start of PE header 指向PE文件头 } IMAGE_DOS_HEADER ENDS</code></pre><p>这个结构中有两字段很重要，一个是e_magic,一个是e_lfanew。e_magic（一个字大小）字段需要被设置为5A4Dh这个也是PE程序载入的重要标志，这个值非常有意思，他们对应的字符分别位Z和M，是为了纪念MS-DOS的最初创建者Mark Zbikowski而专门设置的，由于在hex编辑器中显示是由低位到高位故显示为4D5Ah,刚好是创建者的名字缩写。另一个字段是e_lfanew。这个字段表示的是真正的PE文件头部相对偏移地址（RVA），它指出了真正PE头部文件偏移位置。它占用四个字节，位于文件开始偏移的3ch字节中。<br><img src="https://i.imgur.com/502a8sl.png" alt><br><img src="https://i.imgur.com/1gQk60T.png" alt></p><h2 id="2）PE文件头文件"><a href="#2）PE文件头文件" class="headerlink" title="2）PE文件头文件"></a>2）PE文件头文件</h2><p>紧跟着DOS头文件下面的就是peheader。PEheader是PE相关结构NT映像头（IMAGE_NT_HEADER）的简称，其中包含许多PE装载器用到的重要字段。执行体在支持PE文件结构的操作系统执行时，PE装载器将IMAGE_DOS_HEADER结构中的e_fanew字段找到PEheader的起始偏移量，加上基址得到PE文件头的指针：</p><p>PNTHeader=IMAGBase+dosHeader-&gt;e_lfanewr(其实就是去字段e_lfanew的值)</p><p>下面来讨论IMAGE_NT_HEADER的结构，它是由三个字段组成（左边的数字是PE文件头的偏移量）：<br>    STRUCT </p><pre><code>{ </code></pre><p>​<br>​<br>    +0h Signature  DWORD  //PE文件标志</p><pre><code>+4h FileHeader IMAGE_FILE_HEADER  //文件头初始偏移地址+18 optionalHeader IMAGE_OPTION_HEADER //另一个重要头部初始偏移地址</code></pre><p>​<br>​<br>    } IMAGE_NT_HEADER ENDS</p><p>Signature字段<br>这个字段是PE文件的标志字段，通常设置成00004550h，其ASCII码为PE00，这个字段是PE文件头的开始，前面的DOS_HEADER结构中的字段e_lfanew字段就是指向这里。<br><img src="https://i.imgur.com/K7MP7HM.png" alt><br>IMAGE_FILE_HEADER字段</p><p>这个字段也是包含几个字段结构，它包含了PE文件的一些基本信息，最重要的是其中一个域指出了IMAGE_OPTIONAL_HEADER的大小。<br>    typedef struct _IMAGE_FILE_HEADER {</p><pre><code>WORD Machine;//运行平台WORD NumberOfSections;//文件的区块数目DWORD TimeDateStamp;//文件创建的用时间戳标识的日期DWORD PointerToSymbolTable;//指向符号表（用于调试）DWORD NumberOfSymbols;//符号表中符号的个数WORD SizeOfOptionalHeader;//IMAGE_OPTIONAL_HEADER32结构大小WORD Characteristics;//文件属性} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</code></pre><p><img src="https://i.imgur.com/ao7iSVJ.png" alt></p><p>上图标出七个字段的位置及各自的值。</p><p>1）Machine字段，表示目标CPU 的类型。</p><p>几个常见的及其标识如下：</p><p>机器              标识     </p><p>Intel I386          14ch</p><p>MIPS R3000        162h</p><p>Alpha AXP          184h</p><p>Power PC           1F0h</p><p>MIPS R4000         184h</p><p>根据以上信息我们知道这个PE文件要运行在Intel I386机器上。</p><p>2）NumberOfSection，标识区块的数目，关于区块后面会详细讲。</p><p>3）TimeDateStamp</p><p>这个字段没啥好说的，指的就是PE文件创建的事件，这个时间是指从1970年1月1日到创建该文件的所有的秒数。</p><p>4）PointerToSymbolTable。这个字段用的比较少，略</p><p>5）NumberOfSymbol。这个字段也用得很少，略</p><p>6）SizeOfOptionalHeader：紧跟着IMAGE_FILE_HEADER后面的数据大小，这也是一个数据结构，它叫做IMAGE_OPTIONAL_HEADER,其大小依赖于是64位还是32位文件。32位文件值通常是00EOh，对于64位值通常为00F0h。</p><p>7）Characteristics：文件属性，普通EXE文件这个字段值为010fh，DLL文件这个字段一般是0210h。</p><h2 id="3）IMAGE-OPTIONAL-HEADER概述"><a href="#3）IMAGE-OPTIONAL-HEADER概述" class="headerlink" title="3）IMAGE_OPTIONAL_HEADER概述"></a>3）IMAGE_OPTIONAL_HEADER概述</h2><p>这个结构是IMAGE_FILE_HEADER结构的补充。这个结构异常复杂，但真正我们用得到的其实不多。看下面的代码：<br>    typedef struct _IMAGE_OPTIONAL_HEADER<br>    {<br>    //<br>    // Standard fields.<br>    //<br>    +18hWORDMagic; // 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）<br>    +1AhBYTE  MajorLinkerVersion; // 链接程序的主版本号<br>    +1BhBYTE  MinorLinkerVersion; // 链接程序的次版本号<br>    +1ChDWORD   SizeOfCode; // 所有含代码的节的总大小<br>    +20hDWORD   SizeOfInitializedData;// 所有含已初始化数据的节的总大小<br>    +24hDWORD   SizeOfUninitializedData; // 所有含未初始化数据的节的大小<br>    +28hDWORD   AddressOfEntryPoint;// 程序执行入口RVA<br>    +2ChDWORD   BaseOfCode;  // 代码的区块的起始RVA<br>    +30hDWORD   BaseOfData;  // 数据的区块的起始RVA<br>    //<br>    // NT additional fields.以下是属于NT结构增加的领域。<br>    //<br>    +34hDWORD   ImageBase;  // 程序的首选装载地址                                  !<br>    +38hDWORD   SectionAlignment;  // 内存中的区块的对齐大小                        !<br>    +3ChDWORD   FileAlignment;  // 文件中的区块的对齐大小                           !<br>    +40hWORDMajorOperatingSystemVersion;  // 要求操作系统最低版本号的主版本号<br>    +42hWORDMinorOperatingSystemVersion;  // 要求操作系统最低版本号的副版本号<br>    +44hWORDMajorImageVersion;   // 可运行于操作系统的主版本号<br>    +46hWORDMinorImageVersion;   // 可运行于操作系统的次版本号<br>    +48hWORDMajorSubsystemVersion;  // 要求最低子系统版本的主版本号<br>    +4AhWORDMinorSubsystemVersion;  // 要求最低子系统版本的次版本号<br>    +4ChDWORD   Win32VersionValue;   // 莫须有字段，不被病毒利用的话一般为0<br>    +50hDWORD   SizeOfImage;   // 映像装入内存后的总尺寸<br>    +54hDWORD   SizeOfHeaders;   // 所有头 + 区块表的尺寸大小<br>    +58hDWORD   CheckSum;   // 映像的校检和<br>    +5ChWORDSubsystem;   // 可执行文件期望的子系统<br>    +5EhWORDDllCharacteristics;   // DllMain()函数何时被调用，默认为 0<br>    +60hDWORD   SizeOfStackReserve;   // 初始化时的栈大小<br>    +64hDWORD   SizeOfStackCommit;   // 初始化时实际提交的栈大小<br>    +68hDWORD   SizeOfHeapReserve;// 初始化时保留的堆大小<br>    +6ChDWORD   SizeOfHeapCommit;// 初始化时实际提交的堆大小<br>    +70hDWORD   LoaderFlags;// 与调试有关，默认为 0<br>    +74hDWORD   NumberOfRvaAndSizes;  // 下边数据目录的项数，这个字段自Windows NT 发布以来// 一直是16<br>    +78hDWORD   DataDirctory[16];                                                !<br>       // 数据目录表<br>    } IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</p><p>最常用的是用后面叹号标注的<img src="https://i.imgur.com/bTSe4rn.png" alt></p><p>前面我们已经知道了PE文件头在40h的位置，则上面的偏移量推断IMAGE_OPTIONAL_HEADER字段的首个字段在40h+18h=58h的地方，我们还是用hexwrokshop打开那个PE文件。Ctrl+G打开转移窗口，输入58则找到了第一个字段位置，如下图：<br><img src="https://i.imgur.com/cg9zve8.png" alt><br>下面是DataDirctory[16]即数据目录表的各个成员：<br><img src="https://i.imgur.com/YNQ7DmF.png" alt><br>这张表的16个成员中第一个成员IMAGE_DIRECTORY_ENTRY_EXPORT（导出表）和第二个成员IMAGE_DIRECTORY_ENTRY_EXPORT（导入表）非常重要。<br>用Hexwrokshop打开文件，首先找到PE文件头位置，一般都是在载入起始位+3ch处，如下图所示。<br><img src="https://i.imgur.com/LplosQw.png" alt><br>找到了PE文件头的位置，接下来我们来找DataDirctory[16]各个成员位置。第一个成员输出表位于PE文件头+78h位置即100h+78h=178h处，如下图：<br><img src="https://i.imgur.com/JEYwswl.png" alt></p><p>由于每个结构都占8个字节，所以可以知道输出表的其实位置在4000h处，大小为45h</p><p>输入表的位置位100h+80h=180h处，如下图：<br><img src="https://i.imgur.com/NUAg0g4.png" alt><br>由上图可知输入表的起始位置在3000h处，大小为52h。</p><blockquote><p>查找输入表和输出表的方法还可以用peid或是lordpe</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 逆向工程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux指令记录</title>
      <link href="/2019/10/20/linux%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/10/20/linux%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>编译汇编代码：<br><code>vim hello.asm</code><br><code>nasm -f hello.asm</code><br><code>ld -m  elf_i386 -s -o hello hello.o</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DLL学习</title>
      <link href="/2019/10/17/DLL%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/10/17/DLL%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>库文件:DLL(Dynamic Link Library),是动态链接库文件，又称“应用程序拓展”，是软文件类型。在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。<br>DLL 的编制与具体的编程语言及编译器无关</p><ol><li>只要遵循约定的DLL接口规范和调用方式，用各种语言编写的DLL都可以相互调用。譬如Windows提供的系统DLL（其中包括了Windows的API），在任何开发环境中都能被调用，不在乎其是Visual Basic、Visual C++还是Delphi。</li><li>动态链接库随处可见<br>我们在Windows目录下的system32文件夹中会看到kernel32.dll、user32.dll和gdi32.dll，windows的大多数API都包含在这些DLL中。kernel32.dll中的函数主要处理内存管理和进程调度；user32.dll中的函数主要控制用户界面；gdi32.dll中的函数则负责图形方面的操作。<br>一般的程序员都用过类似MessageBox的函数，其实它就包含在user32.dll这个动态链接库中。由此可见DLL对我们来说其实并不陌生。<br>要使用加载时动态链接，请在编译和链接应用程序时提供头文件 (.h) 和导入库文件 (.lib)。当您这样做时，链接器将向系统提供加载 DLL 所需的信息，并在加载时解析导出的 DLL 函数的位置。 运行时动态链接在运行时动态链接中，应用程序调用 LoadLibrary 函数或 LoadLibraryEx 函数以在运行时加载 DLL。成功加载 DLL 后，可以使用 GetProcAddress 函数获得要调用的导出的 DLL 函数的地址。在使用运行时动态链接时，无需使用导入库文件。</li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
